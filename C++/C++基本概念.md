### 一.构造函数

#### 特点

1. 函数名与类名一致
2. 无返回值
3. 可以有参数，可以构成重载
4. 每次创建类的新对象时调用

#### 使用方法

```c++
//1.显示调用
Demo d=Demo();
//2.隐式调用
Demo d();
//使用new动态分配内存，这种情况下，对象没有名称，只能用指针来管理此对象。
Demo *d=new Demo();
```

未定义构造函数时，有默认构造函数，但是存在构造函数时，需要手动提供默认构造函数。

### 二.析构函数

一般会自动调用默认的析构函数。

只用构造函数使用new来分配内存，析构函数才使用delete来释放内存，否则，析构函数实际上没有什么任务。

#### 特点

1. 是一种特殊的成员函数，会在每次删除所创建的对象时执行。
2. 函数名：~类名
3. 无返回值
4. 不带有参数

析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。

### 三.拷贝构造函数

#### 1.定义

**拷贝构造函数**是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。

在类中没有定义拷贝构造函数时，存在一个默认的。

#### 2.适用情况

- 通过使用另一个同类型的对象来初始化新创建的对象。
- 复制对象把它作为参数传递给函数。
- 复制对象，并从函数返回这个对象。

#### 3.特殊情况

如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。

#### 4.代码格式

```c++
classname (const classname &obj) {
   // 构造函数的主体
}
```

**obj** 是一个对象引用，该对象是用于初始化另一个对象的。

### 四.友元函数

友元：友元函数，友元类，友元成员函数。

#### 定义

定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。

友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

#### 使用方法

如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 **friend**

```C++
//类中定义
friend void show();

//类外实现，show不属于此类的成员函数
void show（）
{}
```

### 五.内联函数

#### 定义

**内联函数**是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。

#### 使用方法

函数名前面放置关键字 **inline**，或者直接在类声明中进行定义。

在类定义中的定义的函数都是内联函数，即使没有使用 **inline** 说明符，类声明常将短小的成员函数作为内联函数，

#### 特殊规则

内联函数的特殊规则要求每个使用它们的文件中都对其进行定义，简便方法：将内联函数的定义放在定义类的头文件中。

### 六.this指针

#### 引出this

```c++
//括号中的const表示不会修改被显示访问的对象
//括号后的const表示不会修改被隐示访问的对象
//最前边的const表示返回值为const引用
const Demo & compare(const Demo & d) const;
```

**引用**：速度更快，内存占用更少。

使用引用的注意事项：不要返回指向局部变量或临时对象的引用，函数执行完毕后，对象将消失，引用将指向不存在的数据。

#### 具体实现

```c++
const Demo & compare(const Demo & d) const
{
  if(d.value>value)
  	return d;
  else
  	return *this;
}
```

### 七.对象数组

#### 初始化

```c++
//使用默认构造函数
Demo a1[4];

Demo a2[4]={
  //三个参数的构造函数
  Demo(1,1,1),
  //两个参数的构造函数
  Demo(1,1),
  //默认构造函数
  Demo()
};
//如果只初始化了部分对象，剩下的对象使用默认构造函数
```

#### 原理

首先使用默认构造函数创建数组元素，然后大括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应元素中。

### 八.运算符重载

#### 定义

只是将函数名改为 operator+（只是用+来举例），其他不变。

#### 使用

```c++
//函数表示法
c=a.operotor+(b);
//运算符表示法
c=a+b;
```

#### 连续使用

```c++
//合法，转化为函数调用 d=a.operotor+(b.operotor+(c));
d=a+b+c;
```

#### 重载限制

1. 重载后的运算符至少有一个操作数是用户定义的类型，这将防止用户为比标准类型重载运算符。因此，不能将减法运算符（-）重载为计算两个double的值，而不是他们的差。

2. 不能违背运算符原来的句法规则，不能改变优先级。例如：不能将%重载为使用一个操作数。

3. 不能创建新的运算符。

4. 不能重载某些运算符。

   （sizeof），（.）（成员运算符），（.*）（成员指针运算符），（::）（作用域解析运算符），（?:）（条件运算符），（typeid）（一个RTTI运算符），（const_cast）（dynamic_cast）（reinterpret_cast）（static_cast）（强制类型转换运算符）

5. 大多数运算符都可以通过成员或非成员函数进行重载，但是某些只能通过成员函数进行重载。

   =（赋值运算符），（）（函数调用运算符），[]（下标运算符），->（指针访问类成员的运算符）

#### 重载<<运算符

1.使用友元函数

如果使用成员函数重载<<，调用方法 t<<cout

所以使用友元函数

```c++
void operator<<(osream & os,const Time & t)
{
	os<<t.value<<endl;
}
```

2.解决不能连续使用<<的问题

```c++
osream & operator<<(osream & os,const Time & t)
{
	os<<t.value<<endl;
	return os;
}
```

#### 使用情况

```c++
//成员函数
Time operator+(const Time & t) const;
//友元函数
friend Time operator+(const Time & t1,const Time & t2);
```

这两个都与a+b匹配，定义运算符时，必须选择其中的一种，不能同时选择。

### static成员变量

使用 **static** 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。

静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 **::** 来重新声明静态变量从而对它进行初始化，

```C++
class CDemo{
public:
	static int count;
  
};

//初始化
int CDemo::count=0;
```

### static成员函数

1. 静态成员函数即使在类对象不存在的情况下也能被调用，**静态函数**只要使用类名加范围解析运算符 **::** 就可以访问。
2. 静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。
3. 静态成员函数有一个类范围，他们不能访问类的 this 指针。

#### 与普通成员函数区别

- 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。
- 普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。

### 继承

####  基类（父类） & 派生类（子类）

支持多继承（java中不支持多继承）

```c++
class derived-class: access-specifier base-class
```

其中，访问修饰符 access-specifier 是 **public、protected** 或 **private** 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。

```c++
//基类
class Shape 
{}；

//派生类
class Rectangle: public Shape
{};
```

#### 访问控制和继承

派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。

| 访问   | public | protected | private |
| ---- | ------ | --------- | ------- |
| 同一个类 | yes    | yes       | yes     |
| 派生类  | yes    | yes       | no      |
| 外部的类 | yes    | no        | no      |

一个派生类继承了所有的基类方法，但下列情况除外：

- 基类的构造函数、析构函数和拷贝构造函数。
- 基类的重载运算符。
- 基类的友元函数。

#### 继承类型

当一个类派生自基类，该基类可以被继承为 **public、protected** 或 **private** 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。

几乎不使用 **protected** 或 **private** 继承，通常使用 **public** 继承。当使用不同类型的继承时，遵循以下几个规则：

- **公有继承（public）：**当一个类派生自**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。
- **保护继承（protected）：** 当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。
- **私有继承（private）：**当一个类派生自**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。

#### 多继承

```c++
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…
{
<派生类类体>
};
```

### 多态

```c++
#include <iostream> 
using namespace std;
 
class Shape {
   public:
      int area()
      {
         cout << "Parent class area :" <<endl;
         return 0;
      }
};
class Rectangle: public Shape{
   public:
      Rectangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout << "Rectangle class area :" <<endl;
         return (width * height); 
      }
};
class Triangle: public Shape{
   public:
      Triangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout << "Triangle class area :" <<endl;
         return (width * height / 2); 
      }
};

int main( )
{
   Shape *shape;
   Rectangle rec(10,7);
   Triangle  tri(10,5);
   
   shape = &rec;
   shape->area();
  
   shape = &tri;
   shape->area();
   
   return 0;
}
```

结果：

```
Parent class area
Parent class area
```

调用函数 area() 被编译器设置为基类中的版本，这就是所谓的**静态多态**，或**静态链接** - 函数调用在程序执行前就准备好了。有时候这也被称为**早绑定**，因为 area() 函数在程序编译期间就已经设置好了。

#### 虚函数

**虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。

#### 纯虚函数

基类中不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。

```c++
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
  	  //= 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。
      virtual int area() = 0;
};
```
