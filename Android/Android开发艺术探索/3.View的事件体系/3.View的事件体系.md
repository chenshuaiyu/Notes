# 3.View的事件体系

### 3.1 View基础知识

#### 3.1.1 什么是View

View是Android中所有控件的基类。

#### 3.1.2 View的位置参数

View的位置只要由它的四个顶点决定，分别对应View的四个属性：top，left，righy，bottom。这些坐标是相对于View的父容器来说的，因此是相对坐标。

![坐标系](E:\Java\Android笔记\Android开发艺术探索\3.View的事件体系\坐标系.png)

```java
left = getLeft();
right = getRight();
top = getTop();
bottom = getBottom();

width = right - left;
height = bottom - top;
```

```
x, y, translationX, translationY
x, y 是View左上角的坐标
translationX, translationY 是View左上角相对于父容器的偏移量
```

这些参数都是**相对于父容器**的坐标，并且translationX, translationY的默认值是0，这些参数间的关系：

```
x = left + translationX;
y = top + translationY;
```

**注意：View在平移的过程中，top，left表示的是原始左上角的位置信息，其值不会发生改变，发生改变的是x, y, translationX, translationY。**

#### 3.1.3 MotionEvent和TouchSlop

##### 1.MotionEvent

ACTION_DOWN：手指刚接触到屏幕。  

ACTION_MOVE：手指在屏幕上移动。  

ACTION_UP：手指从屏幕上松开的一瞬间。

```
//点击事件发生的x和y坐标
getX(), getY() 返回相对于当前View左上角的x和y坐标
getRawX(), getRawY() 返回相对于手机屏幕左上角的x和y坐标
```

##### 2.TouchSlop

TouchSlop是系统能识别出的被认为是滑动的最小距离。如果两次滑动之间的距离小于这个值，系统不认为是在进行滑动操作。

```java
int minDistance = ViewConfiguration.get(getContext()).getScaledTouchSlop();
```

#### 3.1.4 VelocityTracker，GestureDetector和Scroller

##### 1.VelocityTracker

速度追踪，用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。

```java
VelocityTracker mVelocityTracker = VelocityTracker.obtain();
mVelocityTracker.addMovement(event);

mVelocityTracker.computeCurrentVelocity(1000);
int xVelocity = (int) mVelocityTracker.getXVelocity();
int yVelocity = (int) mVelocityTracker.getYVelocity();
```

注意：

1. 获取速度之前必须先计算速度。
2. 速度是指一段时间内手指所滑过的像素数。

不需要使用它的时候，需要调用clear方法来重置并回收内存：

```
mVelocityTracker.clear();
mVelocityTracker.recycle();
```

##### 2.GestureDetector

手势监测，用于辅助检测用户的点击，滑动，长按，双击等行为。

```java
GestureDetector mGestureDetector = new GestureDetector(getContext(), new GestureDetector.OnGestureListener() {
    @Override
    public boolean onDown(MotionEvent e) {
        return false;
    }

    @Override
    public void onShowPress(MotionEvent e) {

    }

    @Override
    public boolean onSingleTapUp(MotionEvent e) {
        return false;
    }

    @Override
    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
        return false;
    }

    @Override
    public void onLongPress(MotionEvent e) {

    }

    @Override
    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
        return false;
    }
});

//解决长按屏幕后无法拖动的现象
mGestureDetector.setIsLongpressEnabled(false);
```

在onTouchEvent中：

```java
boolean consume = mGestureDetector.onTouchEvent(event);
return consume;
```

| 方法名               | 描述                                                         | 所属接口            |
| -------------------- | ------------------------------------------------------------ | ------------------- |
| onDown               | 手指轻轻触摸屏幕的一瞬间，由一个ACTION_DOWN触发              | OnGestureListener   |
| onShowPress          | 手指轻轻触摸屏幕，尚未松开或拖动，由一个ACTION_DOWN触发      | OnGestureListener   |
| onSingleTapUp        | 手指（轻轻触摸屏幕后）松开，伴随着1个ACTION_UP而触发，这是单击行为 | OnGestureListener   |
| onScroll             | 手指按下屏幕并拖动，由一个ACTION_DOWN，多个ACTION_MOVE触发，这是拖动行为 | OnGestureListener   |
| onLongPress          | 用户长久地按着屏幕不放，即长按                               | OnGestureListener   |
| onFling              | 用户按下触摸屏，快速滑动后松开，由一个ACTION_DOWN，多个ACTION_MOVE和一个ACTION_UP触发，这是快速滑动行为 | OnGestureListener   |
| onDoubleTap          | 双击，由2次连续的单击组成，它不可能和onSingleTapConfirmed共存 | OnDoubleTapListener |
| onSingleTapConfirmed | 严格的单击行为（和onSingleTapUp的区别，如果触发了onSingleTapConfirmed，那么后面不可能再紧跟着另一个单击行为，即这只可能是单击，而不可能是双击中的一次单击） | OnDoubleTapListener |
| onDoubleTapEvent     | 表示发生了双击行为，在双击的期间，ACTION_DOWN，ACTION_MOVE和ACTION_UP都会触发此回调 | OnDoubleTapListener |

##### 3.Scroller

弹性滑动对象，用于实现View的弹性滑动。当使用scrollTo/scrollBy方法来进行滑动时，没有过渡效果。使用Scroller可以实现有过渡效果的滑动。

Scroller本身无法让View弹性滑动，需要和View的computeScroll方法来配合使用。

```java
Scroller mScroller = new Scroller(mContext);

//缓慢滚动到指定位置
private void smoothScrollTo(int destX, int destY){
    int scrollX = getScrollX();
    int delta = destX - scrollX;
    //1000ms内滑向destX，效果就是慢慢滑动
    mScroller.startScroll(scrollX, 0 ,delta, 0, 1000);
    invalidate();
}

@Override
public void computeScroll(){
    if(mScroller.computeScrollOffset()){
        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
        postInvalidate();
    }
}

```

### 3.2 View的滑动

#### 3.2.1 使用scrollTo/scrollBy

scrollBy调用了scrollTo方法，scrollBy是基于当前位置的相对滑动，scrollTo是绝对滑动。

从左往右滑动时，mScrollX为负值，反之则为正值。

从上往下滑动时，mScrollY为负值，反之则为正值。

注意：直接使用这两个方法只会将View的内容移动，若想移动整个View需使用`((View)(getParent())).scrollBy()`。

#### 3.2.2 使用动画

即可以使用传统动画，也可以使用属性动画。

```xml
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android"
    android:fillAfter="true"
    android:zAdjustment="normal">

    <translate
        android:duration="100"
        android:fromXDelta="0"
        android:fromYDelta="0"
        android:interpolator="@android:anim/linear_interpolator"
        android:toXDelta="100"
        android:toYDelta="100" />

</set>
```

```java
//Android3.0以下无法使用属性动画
ObjectAnimator.ofFloat(targetView, "translationX", 0, 100).setDuration(100).start();
```

View动画是对View的影像做操作，它并不能真正改变View的位置参数，入股希望动画后的状态还必须设置`android:fillAfter="true"`，否则动画完成后其动画效果会消失。使用属性动画不会存在以上问题。

View变化后，只有点击原始位置才会触发点击事件，View的真身并没有发生改变。

#### 3.2.3 改变布局参数

第三种实现View滑动的方法，改变布局参数，即改变Layoutparams。

```java
MarginLayoutParams params = (MarginLayoutParams) mButton.getLayoutParams();
params.width += 100;
params.leftMargin +=100;
mButton.requestLayout();
//或者
//mButton.setLayoutParams(params);
```

#### 3.2.4 各种滑动方式的对比

使用scrollTo/scrollBy：只能滑动内容，不能滑动本身。

动画：Android3.0以上使用属性动画没有明显缺点，View动画和Android3.0以下均不能改变View本身属性。

改变布局参数：适用对象是具有交互性的View。

### 3.3 弹性滑动









###### 























