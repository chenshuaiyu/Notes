# 消息机制

### 一、消息机制概述

#### 1.消息机制简介

Handle是Android机制的上层接口，通过它可以将一个任务切换到Handle所在的线程去执行。通常情况下，Handle的使用场景就是更新UI。

```java
private Handler mHandler = new Handler(){
    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        switch (msg.what)
        {
            case UPDATE_TEXT:
                textView.setText("1234");
                break;
            default:break;
        }
    }
};
@Override
public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) {
    super.onCreate(savedInstanceState, persistentState);
    setContentView(R.layout.activity_main);
    new Thread(new Runnable() {
        @Override
        public void run() {
            //耗时操作
            Message message=new Message();
            message.what = UPDATE_TEXT;
            handler.sendMessage(message);
        }
    }).start();
}
```

在子线程中，进行耗时操作，发送消息，通过Handle所在进程更新UI。

#### 2.消息机制模型

- MessageQueue：消息队列，但是内部实现不是队列，实际上是用过一个单链表来维护消息队列，因为单链表在插入和删除比较有优势，主要功能向消息池投递消息和取走消息。
- Handle：主要功能向消息池发送各种消息事件，和处理相应消息事件。
- Looper：不断循环执行，从MessageQueue中读取消息，
- Message：需要传递的信息，可以传递数据。按分发机制分发给目标处理者。

#### 3.消息机制架构

消息机制运行流程：

在子线程执行完耗时操作，当handle发送消息时，将会调用`MessageQueue.enqueueMessage`，向目标队列中添加消息，当通过`Lopper.loop`开启消息循环后，即调用`MessageQueue.next`，然后调用目标handle（即发送该消息的Handle）的`dispatchMessage`方法传递消息，然后返回到Handle所在线程，目标Handle收到消息，调用`handleMessge`方法，处理消息。

**Message、Handle、Looper三者之间的关系：**

每个线程中只有一个Looper，Looper是保存在ThreadLocal中的，主线程（UI线程）已经创建一个Looper，所以在主线程中不需要在创建Looper，但是在其他线程中需要创建Looper，每个线程中可以有多个Handle，即一个Handle可以处理来自多个Handle的消息，Looper中维护一个MessageQueue，来维护消息队列，消息队列中的Message可以来自不同的Handle。

### 二、消息机制源码分析

