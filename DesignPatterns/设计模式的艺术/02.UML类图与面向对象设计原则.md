# 2.UML类图与面向对象设计原则

### 2.1 UML概述

UML(Unified Modeling Language，统一建模语言)。

UML结构：

- 视图
- 图
- 模型元素
- 通用机制

### 2.2 类与类的UML图示

在UML2.0的13种图形中，类图是使用频率最高的两种UML图之一（另一种是用于需求建模的用例图），它用于描述系统中包含的类以及他们之间的相互关系。

#### 1.类

类（Class）封装了数据和行为，实现面向对象的重要组成部分，它是具有相同属性、操作、关系的对象集合的总称。

类图是用出现在系统中的不同类来描述系统的静态结构，主要用来描述不同的类以及它们之间的关系。

#### 2.类的UML图示

在UML中，类使用包含类型、属性和操作且带有分割线的长方形来表示。

![Employee](https://github.com/chenshuaiyu/Notes/blob/master/DesignPatterns/设计模式的艺术/assets/Employee.jpg)

```java
public class Employee{
    private String name;
    private int age;
    private String email;
    
    public void modifyInfo(){
        ...
    }
}
```

在UML类图中，类一般由三部分组成：

1.类名：每个类都必须有一个名字，类名是一个字符串。

2.类的属性（Attributes）：属性是指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性。

UML规定属性的表示方式为：

```
可见性 名称:类型[ = 默认值]
```

1. **可见性**表示该属性对于类外的元素而言是否可见，包括共有（public）、私有（private）和受保护（protected）3种，在类图中分别用符号+、-和#表示。
2. **名称**表示属性名，用一个字符串表示。
3. **类型**表示属性的数据类型，可以是基本数据类型，也可以是自定义类型。
4. **默认值**是一个可选项，即属性的初始值。

3.类的操作（Operations）：操作是类的任意一个实例对象都可以使用的行为，是类的成员方法。

UML规定操作的表示方式为：

```
可见性 名称（参数列表）[: 返回类型]
```

1. **可见性**的定义与属性的可见性定义相同。
2. **名称**即方法名，用一个字符串表示。
3. **参数列表**表示方法的参数，其语法与属性的定义相似，参数个数是任意的，多个参数之间用逗号隔开。
4. **返回类型**是一个可选项，表示方法的返回值类型，依赖于具体的编程语言，可以是基本数据类型，也可以是用户自定义类型，还可以是空类型（void），如果是构造方法，则无返回值。

### 2.3 类之间的关系

#### 1.关联关系

关联关系是类与类之间最常用的一种关系，它是一种结构化的关系，用于表示一类对象与另一类对象之间有联系，如汽车和轮胎、师傅和徒弟、班级和学生等。

在UML类中，用**实线**连接有关联关系的对象所对应的类，在Java、C#和C++等编程语言实现关联关系时，通常将一个类的对象作为另一个类的成员变量。在使用类图表示关联关系时可以在关联线上标注角色名，一般使用一个表示两者之间关系的动词或者名次表示角色名（有时该名词为实例对象名），关系的两端代表两种不中的角色，因此在一个关联关系中可以包含两个角色名，角色名不必须的，可以根据需要增加，其目的是使类之间的关系更加明确。

如在一个登录界面类LoginForm中包含一个JButton类型的注册按钮loginButton，它们之间可以表示为关联关系，代码实现可以在LoginForm中定义一个名为loginButton的属性对象，其类型为JButton，

![关联关系实例](https://github.com/chenshuaiyu/Notes/blob/master/DesignPatterns/设计模式的艺术/assets/关联关系实例.jpg)

```java
public class LoginForm{
    private JButton loginButton;//定义为成员变量
    ...
}

public class JButton{
    ...
}
```

在UML中，关联关系通常又包含如下几种形式。

##### 1.双向关联

**默认情况下，关联是双向的**。例如，顾客（Customer）购买商品（Product）并拥有商品，反之，卖出的商品总有某个客户与之相关联。因此，Customer类与Product类之间具有双向关联关系，

![双向关联实例](https://github.com/chenshuaiyu/Notes/blob/master/DesignPatterns/设计模式的艺术/assets/双向关联实例.jpg)

```java
public class Customer{
    private Product[] products;
    ...
}

public class Product{
    private Customer customer;
    ...
}
```

##### 2.单向关联

类的关联关系也可以是单向的，在UML中单向关联用带箭头的实线表示。例如，顾客（Customer）拥有地址（Address），则Customer类与类Address具有单向关联关系，

![单向关联实例](https://github.com/chenshuaiyu/Notes/blob/master/DesignPatterns/设计模式的艺术/assets/单向关联实例.jpg)

```java
public class Customer{
    private Address address;
    ...
}

public class Address{
    ...
}
```

##### 3.自关联

在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联节点称为自关联。例如，一个节点类（Node）的成员又是结点Node类型的对象，

![自关联实例](https://github.com/chenshuaiyu/Notes/blob/master/DesignPatterns/设计模式的艺术/assets/自关联实例.jpg)

```java
public class Node{
    private Node subNode;
    ...
}
```

##### 4.多重性关联

多重性关联又称为重数性（Multiplicity）关联关系，表示两个关联对象在数量上的对应关系。在UML中，对象之间的多重性可以直接在关联直线上用一个数字或一个数字范围表示。

对象之间可以存在多种多重性关联关系，常见的多重性表示方式，

| 表示方式 | 多重性说明                                                   |
| -------- | ------------------------------------------------------------ |
| 1..1     | 表示另一个类的一个对象只与该类的一个对象有关系               |
| 0..*     | 表示另一个类的一个对象与该类的零个或多个对象有关系           |
| 1..*     | 表示另一个类的一个对象与该类的一个或多个对象有关系           |
| 0..1     | 表示另一个类的一个对象没有或只与该类的一个对象有关系         |
| m..n     | 表示另一个类的一个对象与该类最少m，最多n个对象有关系（m ≤ n） |

例如，一个界面（Form）可以拥有零个或多个按钮（Button），但是一个按钮只能属于一个界面，因此，一个Form类的对象只能与零个或多个Button类的对象相关联，但一个Button类的对象只能与一个Form类的对象关联，

![多重性关联实例](https://github.com/chenshuaiyu/Notes/blob/master/DesignPatterns/设计模式的艺术/assets/多重性关联实例.jpg)

```java
public class Form{
    private Button[] buttons;
    ...
}

public class Button{
    ...
}
```

##### 5.聚合关系

聚合（Aggregation）关系表示整体与部分的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。

例如，汽车发动机（Engine）是汽车（Car）的组成部分，但是汽车发动机可以独立存在，因此，汽车与发送机是聚合关系，

![聚合关系实例](https://github.com/chenshuaiyu/Notes/blob/master/DesignPatterns/设计模式的艺术/assets/聚合关系实例.jpg)

```java
public class Car{
    private Engine engine;
    
    //构造注入
    public Car(Engine engine){
        this.engine = engine;
    }
    
    //设值注入
    public void setEngine(Engine engine){
        this.engine = engine;
    }
    ...
}

public class Engine{
    ...
}
```

##### 6.组合关系

组合（Composition）关系也表示类之间整体与部分的关系，但是在组合关系中整体对象可以控制对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象具有同生共死的关系。在UML中，组合关系用带实心菱形的直线表示。例如，人的头（Head）和嘴巴(Mouth)，嘴巴是头的组成部分之一，而且如果头没了，嘴巴也就没了，因此头和嘴巴是组合关系，

![组合关系实例](https://github.com/chenshuaiyu/Notes/blob/master/DesignPatterns/设计模式的艺术/assets/组合关系实例.jpg)

```java
public class Head{
    private Mouth mouth;
    
    public Head(){
        mouth = new Mouth();
    }
    ...
}

public class Mouth{
    ...
}
```

#### 2.依赖关系

依赖（Dependency）关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事务，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。例如，驾驶员开车，在Driver类的drive()方法中将Car类型的对象car作为一个参数传递，以便在drive()方法中能够调用Car类的move()方法，且驾驶员的drive()方法依赖车的move()方法，因此类Driver依赖类Car，

![依赖关系实例](https://github.com/chenshuaiyu/Notes/blob/master/DesignPatterns/设计模式的艺术/assets/依赖关系实例.jpg)

```java
public class Driver{
    public void drive(Car car){
        car.move();
    }
    ...
}

public class Car{
    public void move(){
        ...
    }
}
```

在系统实施阶段，依赖关系通常通过3种方式来实现，第1种也是最常用的一种方法是将一个类的对象作为另一个类中方法的参数；第2种方式是在一个类的方法中将另一个类的对象作为其局部变量；第三种是在一个类的方法中调用另一个类的静态方法。

#### 3.泛化关系

泛化（Generalization）关系也就是继承关系，用于描述父类与子类的关系，父类又称作基类或超类，子类又称作派生类。在UML中，泛化关系用带空心三角形的直线来表示。在代码实现时，使用面向对象的继承机制来实现泛化关系，如在Java语言中使用extends关键字、在C++/C#中使用：来实现。例如，Student类和Teacher类都是Person的子类。

![泛化关系实例](https://github.com/chenshuaiyu/Notes/blob/master/DesignPatterns/设计模式的艺术/assets/泛化关系实例.jpg)

```java
//父类
public class Person{
    protected String name;
    protected int age;
    
    public void move(){
        ...
    }
    
    public void say(){
        ...
    }
}

//子类
public class Student{
    private String studentNo;
    
    public void study(){
        ...
    }
}

//子类
public class Teacher{
    private String teacherNo;
    
    public void teach(){
        ...
    }
}
```

#### 4.接口与实现关系

在很多面向对象语言中都引入了接口的概念，如Java、C#等。在接口中，通常没有属性，而且所有的操作都是抽象的，只有操作的声明，没有操作的实现。UML中用与类的表示法类似的方式表示接口。

接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口与类之间还存在一种实现（Realization）关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。

例如，定义了一个交通工具接口Vehicle，包含一个抽象操作move()，在类Ship和类Car中都实现了该move()操作，不过具体的实现细节将会不一样，

![实现关系实例](https://github.com/chenshuaiyu/Notes/blob/master/DesignPatterns/设计模式的艺术/assets/实现关系实例.jpg)

```java
public interface Vehicle{
    public void move();
}

public class Ship implements Vehicle{
    public void move(){
        ...
    }
}

public class Car implements Vehicle{
    public void move(){
        ...
    }
}
```

### 2.4 面向对象设计原则概述

面向对象设计的目标之一在于支持可维护性复用，一方面需要实现设计方案或源代码的重用，另一方面要确保系统能够易于拓展和修改，具有较好的灵活性。面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，他们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是用于评价一个设计模式的使用效果的重要指标之一。

| 设计原则名称                                        | 定义                                             | 使用频率 |
| --------------------------------------------------- | ------------------------------------------------ | -------- |
| 单一职责原则（Single Responsibility Principle,SRP） | 一个类只负责一个功能领域中的相应职责dsfas        | ★★★★☆    |
| 开闭原则（Open-Closed Principle,OCP）               | 软件实体应对拓展开放，面对修改关闭               | ★★★★★    |
| 里氏代换原则（Liskov Substitution Principle,LSP）   | 所有引用基类对象的地方能够透明地使用其子类的对象 | ★★★★★    |
| 依赖倒转原则（Dependence Inversion Principle,DIP）  | 抽象不应该依赖于细节，细节应该依赖于抽象         | ★★★★★    |
| 接口隔离原则（Interface Segregation Principle,ISP） | 使用多个专门的接口，而不使用单一的总接口         | ★★☆☆☆    |
| 合成复用原则（Composite Reuse Principle,CRP）       | 尽量使用对象组合，而不是继承来达到复用的目的     | ★★★★☆    |
| 迪米特法则（Law of Demeter,LoD）                    | 一个软件实体应当尽可能少地与其他实体发生相互作用 | ★★★☆☆    |

### 2.5 单一职责原则

单一职责原则：一个类只负责一个功能领域中的相应职责。或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。

核心思想：一个类不能太“累”。

### 2.6 开闭原则

开闭原则：一个软件实体应当**对拓展开放**，**对修改关闭**。即软件实体应尽量在不修改原有代码的情况下进行拓展。

### 2.7 里氏代换原则

严格表述：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有变化，那么类型S是类型T的子类型。

里氏置换原则：所有引用基类（父类）的地方必须能透明地使用其子类的对象。

里氏置换原则表明，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类。例如，我喜欢动物，那我一定喜欢狗，因为狗是动物的子类，但是我喜欢狗，不能据此推断出我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。

里氏置换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类类型来替换父类对象。

在运用里氏置换原则时，应该将父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，可以很方便地扩展系统的功能，无需修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。

### 2.8 依赖倒转原则

依赖倒转原则：抽象不应该依赖于具体细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。

依赖倒转原则要求在程序代码中传递参数时或在关联关系时，尽量引用层次高的抽象层类，即**使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等**，而不要使用具体类来做这些事情。为了确保该原则的使用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用在子类中增加的新方法。

在实现依赖倒转原则时，需要针对抽象层编程，而将具体类的对象通过依赖注入（Dependenc Injection）的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生以来关系时，通过抽象来注入所依赖的对象。

常用的注入方式：

1. 构造注入：通过构造函数来传入具体类的对象。
2. 设值注入：通过Setter方法来传入具体类的对象。
3. 接口注入：通过实现在接口中声明的业务方法来传入具体类的对象。

### 2.9 接口隔离原则

接口隔离原则：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。

### 2.10 合成复用原则

合成复用原则又称为组合/聚合复用原则。

合成复用原则：尽量使用对象组合，而不是继承来达到复用的目的。

一般而言，如果两个类之间是“Has-A”的关系，应使用组合或聚合，如果是“Is-A”关系，可使用继承。

- Is-A：一个类是另一个类的“一种”。
- Has-A：某一个角色具有某一项责任。

### 2.11 迪米特法则

又称为最少知识原则。

迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。

如果一个类符合迪米特法则，那么当其中一个模块发生修改时，就会尽量少地影响其他模块，拓展会相对容易。这是对软件实体之间通信的限制。迪米特法则要求限制软件实体之间通信得宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。

在迪米特法则中，对于一个对象，其**朋友**包括以下几类：

1. 当前对象本身（this）。
2. 以参数形式传入到当前方法中的对象。
3. 当前对象的成员对象。
4. 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友。
5. 当前对象所创建的对象。

任何一个对象，如果满足上面的条件之一 ，就是当前对象的朋友，否则就是陌生人。 