# 19.迭代器模式

### 19.2 迭代器模式概述

迭代器模式：提供一种方法来访问聚合对象，而不同暴露这个对象的内部表示，其别名是游标（Cursor）。迭代器模式是一种对象行为型模式。

在迭代器模式结构中，包含聚合和迭代器模式两个层次结构，考虑到系统的灵活性和可拓展性，在迭代器模式中应用了工厂方法模式，

![迭代器模式结构图](https://github.com/chenshuaiyu/Notes/blob/master/DesignPatterns/设计模式的艺术/assets/迭代器模式结构图.PNG)

4个角色：

1. Iterator（迭代器模式）：它定义了访问和遍历元素的接口，声明了用于遍历元素的方法，例如，用于获取第一个元素的first()方法，用于访问下一个元素的next()方法，用于判断是否还有下一个元素的hasNext()方法，用于获取当前元素的currentItem()方法等，在具体迭代器中将实现这些方法。
2. ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。
3. Aggregate（抽象聚合类）：它用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。
4. ConcreteAggregate（具体聚合类）：它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。

```java
interface Iterator{
    public void first();//将游标指向第一个元素
    public void next();//将游标指向下一个元素
    public boolean hasNext();//判断是否存在下一个元素
    public Object currentItem();//获取游标指向的当前元素
}

class ConcreteIterator implements Iterator{
    private ConcreteAggregate objects;//维持一个对具体聚合对象的引用，以便于访问存储在聚合对象中的数据
    private int cursor;//定义一个游标，用于记录当前访问位置
    
    public ConcreteIterator(ConcreteAggregate objects){
        this.objects = objects;
    }
    
    public void first(){}
    
    public void next(){}
    
    public boolean hasNext(){}
    
    public Object currentItem(){}
}

interface Aggregate{
    Iterator createIterator();
}

class ConcreteAggregate implements Aggregate{
    public Iterator createIterator(){
        return new ConcreteIterator(this);
    }
}
```

### 19.3 完整解决方案

![销售管理系统数据遍历结构图](https://github.com/chenshuaiyu/Notes/blob/master/DesignPatterns/设计模式的艺术/assets/销售管理系统数据遍历结构图.PNG)

```java
//在本实例中，为了详细说明自定义迭代器的实现过程，没有使用JDK中内置的迭代器，事实上，JDK内置迭代器已经实现了对一个List对象的正向遍历

//抽象聚合类
abstract class AbstractObjectList{
    protected List<Object> objects = new ArrayList<>();
    
    public AbstractObjectList(List objects){
        this.objects = objects;
    }
    
    public void addObject(Object obj){
        this.objects.add(obj);
    }
    
    public void removeObject(Object obj){
        this.objects.remove(obj);
    }
    
    public List getObject(){
        return this.objects;
    }
    
    //声明创建迭代器对象的抽象工厂方法
    public abstract AbstractIterator createIterator();
}

//商品数据类：具体聚合类
class ProductList extends AbstractObjectList{
    public ProductList(List products){
        super(products);
    }
    
    //实现创建迭代器对象的具体工厂方法
    public AbstractIterator createIterator(){
        return new ProductIterator(this);
    }
}

//抽象迭代器
class AbstractIterator{
    public void next();//移至下一个元素
    public boolean isLast();//判断是否为最后一个元素
    public void previous();//移至上一个元素
    public boolean isFirst();//判断是否为第一个元素
    public Object getNextItem();//获取下一个元素
    public Object getPreviousItem();//获取上一个元素
}

//商品迭代器：具体迭代器
class ProductIterator implements AbstractIterator{
    private ProductList productList;
    private List products;
    private int cursor1;//定义一个游标，用于记录正向遍历的位置
    private int cursor2;//定义一个游标，用于记录逆向遍历的位置
    
    public ProductIterator(ProductList list){
        this.productList = list;
        this.products = list.getObject();//获取集合对象
        cursor1 = 0;//设置正向遍历游标的初始值
        cursor2 = products.size() - 1;//设置逆向遍历游标的初始值
    }
    
    public void next() {
        if(cursor1 < objects.size()) {
            cursor1++;
        }
    }

    public boolean isLast() {
        return (cursor1 == objects.size());
    }

    public void previous() {
        if(cursor2 > -1) {
            cursor2--;
        }
    }

    public boolean isFirst() {
        return (cursor2 == -1);
    }

    public Object getNextItem() {
        return objects.get(cursor1);
    } 

    public Object getPreviousItem() {
        return objects.get(cursor2);
    }
}
```

```java
class Client{
    public static void main(String[] args){
        List products = new ArrayList();
        products.add("倚天剑");
        products.add("屠龙刀");
        products.add("断肠草");
        products.add("葵花宝典");
        products.add("四十二章经");
        
        AbstractObjectList list;
        AbstractIterator iterator;
        
        list = new ProductList(products);//创建聚合对象
        iterator = list.createIterator();//创建迭代器对象
        
        System.out.println("正向遍历：");
        while(iterator.isLast()){
            System.out.println(iterator.getNextItem() + "，");
            iterator.next();
        }
        System.out.println();
        System.out.println("---------------");
        System.out.println("逆向遍历：");
        while(iterator.isFirst()){
            System.out.println(iterator.getPreviousItem() + "，");
            iterator.previous();
        }
    }
}
```

```
正向遍历
倚天剑，屠龙刀，断肠草，葵花宝典，四十二章经
---------------
逆向遍历：
四十二章经，葵花宝典，断肠草，屠龙刀，倚天剑
```

### 19.4 使用内部类实现迭代器

为了能够让迭代器可以访问到聚合对象中的数据，还可以将迭代器类设计为聚合类的内部类，JDK中的迭代器类通过这种方法来实现的。

```java
//商品数据类：具体聚合类
class ProductList extends AbstractObjectList{
    public ProductList(List products){
        super(products);
    }
    
    //实现创建迭代器对象的具体工厂方法
    public AbstractIterator createIterator(){
        return new ProductIterator();
    }
    
    //商品迭代器：具体迭代器，内部类实现
    private class ProductIterator implements AbstractIterator{
        private int cursor1;
        private int cursor2;
        
        public ProductIterator(){
            cursor1 = 0;
            cursor2 = objects.size() - 1;
        }
        
        public void next() {
            if(cursor1 < objects.size()) {
                cursor1++;
            }
        }

        public boolean isLast() {
            return (cursor1 == objects.size());
        }

        public void previous() {
            if(cursor2 > -1) {
                cursor2--;
            }
        }

        public boolean isFirst() {
            return (cursor2 == -1);
        }

        public Object getNextItem() {
            return objects.get(cursor1);
        } 

        public Object getPreviousItem() {
            return objects.get(cursor2);
        }
    }
}
```

无论使用哪种实现细节，客户端代码都是一样的，也就是说客户端无须关心具体迭代器对象的创建细节，只需通过调用工厂方法createIterator()即可得到一个可用的迭代器对象，这也是使用工厂方法模式的好处，通过工厂方法来封装对象的创建过程，简化了客户端的调用。

### 19.5 JDK内置迭代器



















