# 19.迭代器模式

### 19.2 迭代器模式概述

迭代器模式：提供一种方法来访问聚合对象，而不同暴露这个对象的内部表示，其别名是游标（Cursor）。迭代器模式是一种对象行为型模式。

在迭代器模式结构中，包含聚合和迭代器模式两个层次结构，考虑到系统的灵活性和可拓展性，在迭代器模式中应用了工厂方法模式，

![迭代器模式结构图](https://github.com/chenshuaiyu/Notes/blob/master/DesignPatterns/设计模式的艺术/assets/迭代器模式结构图.PNG)

4个角色：

1. Iterator（迭代器模式）：它定义了访问和遍历元素的接口，声明了用于遍历元素的方法，例如，用于获取第一个元素的first()方法，用于访问下一个元素的next()方法，用于判断是否还有下一个元素的hasNext()方法，用于获取当前元素的currentItem()方法等，在具体迭代器中将实现这些方法。
2. ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。
3. Aggregate（抽象聚合类）：它用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。
4. ConcreteAggregate（具体聚合类）：它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实例。

```java
interface Iterator{
    public void first();//将游标指向第一个元素
    public void next();//将游标指向下一个元素
    public boolean hasNext();//判断是否存在下一个元素
    public Object currentItem();//获取游标指向的当前元素
}

class ConcreteIterator implements Iterator{
    private ConcreteAggregate objects;//维持一个对具体聚合对象的引用，以便于访问存储在聚合对象中的数据
    private int cursor;//定义一个游标，用于记录当前访问位置
    
    public ConcreteIterator(ConcreteAggregate objects){
        this.objects = objects;
    }
    
    public void first(){}
    
    public void next(){}
    
    public boolean hasNext(){}
    
    public Object currentItem(){}
}

interface Aggregate{
    Iterator createIterator();
}

class ConcreteAggregate implements Aggregate{
    public Iterator createIterator(){
        return new ConcreteIterator(this);
    }
}
```

### 19.3 完整解决方案

![销售管理系统数据遍历结构图](https://github.com/chenshuaiyu/Notes/blob/master/DesignPatterns/设计模式的艺术/assets/销售管理系统数据遍历结构图.PNG)

```java
//在本实例中，为了详细说明自定义迭代器的实现过程，没有使用JDK中内置的迭代器，事实上，JDK内置迭代器已经实现了对一个List对象的正向遍历

//抽象聚合类
abstract class AbstractObjectList{
    protected List<Object> objects = new ArrayList<>();
    
    public AbstractObjectList(List objects){
        this.objects = objects;
    }
    
    public void addObject(Object obj){
        this.objects.add(obj);
    }
    
    public void removeObject(Object obj){
        this.objects.remove(obj);
    }
    
    public List getObject(){
        return this.objects;
    }
    
    //声明创建迭代器对象的抽象工厂方法
    public abstract AbstractIterator createIterator();
}

//商品数据类：具体聚合类
class ProductList extends AbstractObjectList{
    public ProductList(List products){
        super(products);
    }
    
    //实现创建迭代器对象的具体工厂方法
    public AbstractIterator createIterator(){
        return new ProductIterator(this);
    }
}

//抽象迭代器
class AbstractIterator{
    public void next();//移至下一个元素
    public boolean isLast();//判断是否为最后一个元素
    public void previous();//移至上一个元素
    public boolean isFirst();//判断是否为第一个元素
    public Object getNextItem();//获取下一个元素
    public Object getPreviousItem();//获取上一个元素
}

//商品迭代器：具体迭代器
class ProductIterator implements AbstractIterator{
    private ProductList productList;
    private List products;
    private int cursor1;//定义一个游标，用于记录正向遍历的位置
    private int cursor2;//定义一个游标，用于记录逆向遍历的位置
    
    public ProductIterator(ProductList list){
        this.productList = list;
        this.products = list.getObject();//获取集合对象
        cursor1 = 0;//设置正向遍历游标的初始值
        cursor2 = products.size() - 1;//设置逆向遍历游标的初始值
    }
    
    public void next() {
        if(cursor1 < objects.size()) {
            cursor1++;
        }
    }

    public boolean isLast() {
        return (cursor1 == objects.size());
    }

    public void previous() {
        if(cursor2 > -1) {
            cursor2--;
        }
    }

    public boolean isFirst() {
        return (cursor2 == -1);
    }

    public Object getNextItem() {
        return objects.get(cursor1);
    } 

    public Object getPreviousItem() {
        return objects.get(cursor2);
    }
}
```

```java
class Client{
    public static void main(String[] args){
        List products = new ArrayList();
        products.add("倚天剑");
        products.add("屠龙刀");
        products.add("断肠草");
        products.add("葵花宝典");
        products.add("四十二章经");
        
        AbstractObjectList list;
        AbstractIterator iterator;
        
        list = new ProductList(products);//创建聚合对象
        iterator = list.createIterator();//创建迭代器对象
        
        System.out.println("正向遍历：");
        while(iterator.isLast()){
            System.out.println(iterator.getNextItem() + "，");
            iterator.next();
        }
        System.out.println();
        System.out.println("---------------");
        System.out.println("逆向遍历：");
        while(iterator.isFirst()){
            System.out.println(iterator.getPreviousItem() + "，");
            iterator.previous();
        }
    }
}
```

```
正向遍历：
倚天剑，屠龙刀，断肠草，葵花宝典，四十二章经
---------------
逆向遍历：
四十二章经，葵花宝典，断肠草，屠龙刀，倚天剑
```

### 19.4 使用内部类实现迭代器

为了能够让迭代器可以访问到聚合对象中的数据，还可以将迭代器类设计为聚合类的内部类，JDK中的迭代器类通过这种方法来实现的。

```java
//商品数据类：具体聚合类
class ProductList extends AbstractObjectList{
    public ProductList(List products){
        super(products);
    }
    
    //实现创建迭代器对象的具体工厂方法
    public AbstractIterator createIterator(){
        return new ProductIterator();
    }
    
    //商品迭代器：具体迭代器，内部类实现
    private class ProductIterator implements AbstractIterator{
        private int cursor1;
        private int cursor2;
        
        public ProductIterator(){
            cursor1 = 0;
            cursor2 = objects.size() - 1;
        }
        
        public void next() {
            if(cursor1 < objects.size()) {
                cursor1++;
            }
        }

        public boolean isLast() {
            return (cursor1 == objects.size());
        }

        public void previous() {
            if(cursor2 > -1) {
                cursor2--;
            }
        }

        public boolean isFirst() {
            return (cursor2 == -1);
        }

        public Object getNextItem() {
            return objects.get(cursor1);
        } 

        public Object getPreviousItem() {
            return objects.get(cursor2);
        }
    }
}
```

无论使用哪种实现细节，客户端代码都是一样的，也就是说客户端无须关心具体迭代器对象的创建细节，只需通过调用工厂方法createIterator()即可得到一个可用的迭代器对象，这也是使用工厂方法模式的好处，通过工厂方法来封装对象的创建过程，简化了客户端的调用。

### 19.5 JDK内置迭代器

在Java集合框架中，常用的List和Set等聚合类的子类都间接实现了java.uitl.Collection接口，在Collection接口中声明了如下方法（部分）：

```java

```









### 19.6 迭代器模式总结

#### 1. 主要优点

1. 它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。
2. 迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。
3. 在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求。

#### 2. 主要缺点

1. 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。
2. 抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如JDK内置迭代器Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情。

#### 3. 适用场景

1. 访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。
2. 需要为一个聚合对象提供多种遍历方式。
3. 为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。