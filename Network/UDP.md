# UDP

### 1. 概述

1. UDP是无连接的，即发送数据之前不需要建立连接（当然，发送数据结束时也没有连接可释放），因此减少了开销和发送数据之前的时延。
2. UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
3. UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付至IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。在接收方的UDP，对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程。也就是说，**UDP一次交付一个完整的报文**。因此，应用程序必须选择合适大小的报文。若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。反之，若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，这也降低了IP层的效率。![UDP是面向报文的](https://github.com/chenshuaiyu/Notes/blob/master/Network/assets/UDP是面向报文的.PNG)
4. UDP没有拥塞控制，因此网络出现的拥塞不会源主机的发送效率降低。
5. UDP支持一对一、一对多、多对一和多对多的交互通信。
6. UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短很多。

### 2. UDP的首部格式

用户数据报UDP有两个字段：数据字段和首部字段。首部字段8字节，由四个字段组成，每个字段的长度都是两个字节。

![UDP用户数据报的首部和伪首部](https://github.com/chenshuaiyu/Notes/blob/master/Network/assets/UDP用户数据报的首部和伪首部.PNG)

1. 源端口：源端口号。在需要对方回信时选用。不需要时可用全0。
2. 目的端口：目的端口号。这在终端交付报文时必须使用。
3. 长度：UDP用户数据报的长度，其最小值是8（仅有首部）。
4. 检验和：检验UDP用户数据报在传输中是否有错。有错就丢弃。

![UDP基于端口的分用](https://github.com/chenshuaiyu/Notes/blob/master/Network/assets/UDP基于端口的分用.PNG)

如果接收方UDP发现收到的报文中目的端口号不正确（即不存在对应于该端口号的应用进程），就丢弃该报文，并由忘记控制报文协议ICMP发送“端口不可达”差错报文给发送方。

注意：

虽然在UDP之间的通信要用到端口号，但由于UDP的通信是无连接的，因此不需要使用套接字来建立连接（TCP之间的通信必须要在两个套接字之间建立连接）。

在计算校验和时，要在UDP用户报之前增加12字节的伪首部。所谓“伪首部”是因为这种伪首部并不是UDP用户数据报真正的首部。只是在计算检验和时，临时添加在UDP用户报前面，得到一个临时的UDP用户数据报。检验和就是按照这个临时的UDP用户数据包来计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算检验和。

UDP计算检验和的方法和计算IP数据报首部检验和的方法相似，但不同的是，IP数据报的检验和只检验IP数据报的首部，但UDP的检验和是把首部和数据部分一起都检验。

**发送方**：首先是先把全0放入检验和字段。再把伪首部以及UDP用户数据报看成是由许多16位的字串节接起来的。若UDP用户数据报的数据部分不是偶数个字节，则要填入一个全0字节（但此字节不发送）。然后按二进制反码计算出这些16位字的和。将此和的二进制反码写入检验和字段，就发送这样的UDP用户数据报。

**接收方**：把收到的UDP用户数据报连同伪首部（以及可能的填充全0字节）一起，按二进制反码求这些字的和。当无差错时其结果应为全1。否则就表明有差错出现，接收方就应丢弃这个UDP用户数据包（也可以上交给应用层，但附上出现了差错的警告）。

![计算UDP检验和的例子](https://github.com/chenshuaiyu/Notes/blob/master/Network/assets/计算UDP检验和的例子.PNG)