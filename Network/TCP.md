

# TCP

### 1. 概述

#### 1.TCP最主要的特点

1. TCP是面向连接的运输层协议。这就是说，应用程序在使用TCP协议之前，必须先建立TCP连接。在传输数据完毕后，必须释放已经建立的TCP连接。也就是说，应用进程之间的通信好像在打电话：通话之前要先拨号建立连接，通话结束后要挂机释放连接。
2. 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）。
3. TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达。
4. TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接受缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给TCP的缓存后，就可以做自己的事，而TCP在合适的时候把数据发送从出去。在接收时，TCP把收到的的数据存入缓存，上层的应用程序在合适的时候读取缓存中的数据。
5. 面向字节流。TCP中的“流”指的是流入到进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。TCP并不知道所传送的字节流的含义。TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流一样。当然接收方的应用程序必须有能力识别收到的字节流，把它还原成有意义的应用层数据。

TCP连接是一条**虚连接**（也就是逻辑连接），而不是一条真正的物理连接。TCP报文段先要传送到IP层，加上IP首部后，在传送到数据链路层，再加上数据链路层的首部和尾部后，才离开主机发送到物理链路。

TCP和UDP在发送报文时所采用的方式完全不同。TCP并不关心应用进程一次把多大的报文发送到TCP的缓存中，而是根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP发送的报文长度是应用进程给出的）。如果应用进程传送到TCP缓存的数据太长，TCP就可以把它划分短一些再发送。如果应用程序一次只发来一个字节，TCP也可以等待激烈积累有足够多的字节后在构成报文段发送出去。

#### 2. TCP的连接

TCP把连接作为最基本的抽象。

套接字 socket =（IP地址 ：端口号）

同一个IP地址可以有多个不同的TCP连接，而同一个端口也可以出现在多个不同的TCP连接中。

### 2. 可靠传输的工作原理

TCP发送的报文段是交给IP层传送，但IP层只能提供尽最大努力服务，也就是说，TCP下面的网络所提供的是不可靠的传输。因此，TCP必须采取适当的措施才能使得两个运输层之间的通信变得可靠。

理想的传输条件特点：

1. 传输信道不产生差错。
2. 不管发送方以多快的速度发送数据，接收方总是来得及从处理收到的数据。

#### 1. 停止等待协议

“停止等待”就是每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组。

![停止等待协议](https://github.com/chenshuaiyu/Notes/blob/master/Network/assets/停止等待协议.PNG)

超时重传：

1. A在发送完一个分组后，必须暂时保留已发送的分组的副本（在发生超时重传时使用）。只有在收到相应的确认后才能清除暂时保留的分组副本。
2. 分组和确认都必须进行编号，这样才能明确哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认。
3. 超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。

![确认丢失和确认迟到](https://github.com/chenshuaiyu/Notes/blob/master/Network/assets/确认丢失和确认迟到.PNG)

确认丢失：
假定B又收到了重传的分组M1，这时应采取两个活动：

1. 丢弃这个重复的分组，不向上层交付。
2. 向A发送确认，不能认为已经发送过确认就不再发送，因为A之所以重传就表示A没有收到对M1的确认。

确认迟到：

B对分组M1的确认迟到了，A会收到重复的确认。对重复的确认的处理很简单：收下就丢弃。B仍然会收到重复的M1，并且同样要丢弃重复的M1，并重传确认分组。

信道利用率：

![停止等待协议的信道利用率太低](https://github.com/chenshuaiyu/Notes/blob/master/Network/assets/停止等待协议的信道利用率太低.PNG)
$$
U=\frac{T_D}{T_D+RTT+T_A}
$$

- T_D：发送分组时间
- RTT：往返时间
- T_A：发送确认分组时间

#### 2. 连续ARQ协议

![连续ARQ协议的工作原理](https://github.com/chenshuaiyu/Notes/blob/master/Network/assets/连续ARQ协议的工作原理.PNG)

连续ARQ协议规定：

发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。

接受方一般都是采用累积确认的方法。这就是说，接受方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的租后一个分组发送确认，这就表示：到这个分组为止的所有分组都已经正确收到了。

- 优点：容易实现，即使确认丢失也不必重传。
- 缺点：不能向发送方反映出接受方已经正确收到的所有分组的信息。

Go-back-N（后退N）：表示需要再退回来重传已发送过的N个分组。

### 3. TCP报文的首部格式

![TCP报文段的首部格式](https://github.com/chenshuaiyu/Notes/blob/master/Network/assets/TCP报文段的首部格式.PNG)

### 4. TCP可靠传输的实现

#### 1. 以字节为单位的滑动窗口

![根据B构造A的发送窗口](https://github.com/chenshuaiyu/Notes/blob/master/Network/assets/根据B构造A的发送窗口.PNG)

A收到B发来的确认报文段，其中窗口是20字节，而确认号是31，这表明B期望收到的下一个序号是31，而序号30为止的数据已经收到了。

- 发送窗口：在没有收到B的确认的情况下，A可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。
- 接收窗口：接收方会把自己的接收窗口数值放在窗口字段中发送给对方。因此，A的发送窗口一定不能超过B的接收窗口数值。

发送窗口后沿的后面部分表示已发送且已收到了确认。这些数据显然不需要再保留了。而发送窗口前沿的前面部分表示不允许发送的，因为接收方都没有为这部分数据保留临时存放的缓存。

发送窗口的位置由窗口前沿和后沿的位置共同决定。发送窗口后沿的变化情况有两种可能：即不动（没有收到新的确认）和前移（收到了新的通知）。发送窗口后沿不可能向后移动，因为不能撤销掉已收到的确认。发送窗口前沿通常是不断向前移动，但也有可能不动。这对应于两种情况：一是没有收到新的确认，对方通知的窗口大小也不变；二是收到了新的确认但对方通知的窗口缩小了，使得发送窗口前沿正好不动。

注意：

发送窗口前沿也有**向后收缩**，这发生在对方通知的窗口缩小了。但TCP的标准强烈不赞成这样做。因为很可能发送方在收到这个通知以前已经发送了窗口中的许多数据，现在又要收缩窗口。不让发送这些数据，这样就产生一些错误。

![A发送了11字节的数据](https://github.com/chenshuaiyu/Notes/blob/master/Network/assets/A发送了11字节的数据.PNG)

要描述一个发送窗口的状态需要三个指针：P1、P2、P3。

- 小于P1 的是已发送并已收到确认的部分，而大于P3的是不允许发送的部分。
- P3 - P1 = A的发送窗口
- P2 - P1 = 已发送但尚未收到确认的字节数
- P3 - P3 = 允许发送但当前尚未发送的字节数（又称为可用窗口或有效窗口）

B的接收窗口大小是20字节，到30号为止的数据是已经发送过确认，并且已经交付主机了。在B收到了序号为32和33的数据。这些数据没有按序到达，因为序号为31的数据没有收到。B只能对按序手收到的数据中的最高序号给出确认，因此B发送的确认报文段中的确认号仍然是31号，而不能是32或33。

重传：A发送窗口中的数据已经正确到达B，B也早已发出了确认，但不幸的是，所有这些确认都滞留在了网络中，A只能认为B还没有收到这些数据，A在经过一段时间内（由超时计时器控制）就重传这部分数据，重新设置超时计数器，直到收到B的确认位置。如果A收到确认号落在发送窗口内，那么A就可以使发送窗口继续向前滑动，并发送新的数据。

TCP缓存和窗口的关系：

![TCP的缓存和窗口的数据](https://github.com/chenshuaiyu/Notes/blob/master/Network/assets/TCP的缓存和窗口的数据.PNG)

发送缓存：

1. 发送应用程序传送给发送方TCP准备发送的数据。
2. TCP已发送但尚未收到确认的数据。

发送窗口只是发送缓存的一部分。已被确认的数据应当从发送缓存中删除，因此发送缓存和发送窗口的后沿是重合的。发送应用程序最后写入发送缓存的字节减去最后被确认的字节，就是还保留在发送缓存中的被写入的字节数。

接收缓存：

1. 按序到达的、尚未被接收应用程序读取的数据。
2. 未按需到达的数据。

注意：

1. 虽然A的发送窗口是根据B的接收窗口设置的，但在同一时刻，A的发送窗口并不总是B的接收窗口一样大。这是因为通过网络传送窗口值需要经历一定的时间滞后。
2. 对于不按序到达的数据应如何处理，TCP标准并无明确规定。
3. TCP要求接受方必须有累计确认的功能，这样可以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据发送时把确认信息捎带上。但注意两点，一是接收放不应过分推迟发送确认，否则会导致确认方不必要的重传，这反而浪费了网络的资源。二是捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。

#### 2. 超时重传时间的选择

TCP的发送方在规定的时间内没有收到确认就要重传已发送的报文段。
$$
新的RTT_s=(1-α)×(旧的RTT_s)+α×(新的RTT样本)
$$
α=0.125
$$
超时重传时间RTO=RTT_s+4×RTT_D
$$

$$
新的RTT_D=(1-β)×(旧的RTT_s)+β×|RTT_s-新的RTT样本|
$$

β=0.25

### 5. TCP的流量控制

流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。

![利用可变窗口进行流量控制](https://github.com/chenshuaiyu/Notes/blob/master/Network/assets/利用可变窗口进行流量控制.PNG)

发送方的发送窗口不能超过接受方给出的接受窗口的数值。TCP的窗口单位是字节，不是报文段。

ACK表示首部中的确认位，ack表示确认字段的值。

死锁：

B向A发送了零窗口的报文段后不久，B的接受缓存又有一些存储空间。于是B向A发送了rwnd=400是的报文段。然而这个报文段在传送过程中丢失了。A一直等待收到B发送的非零窗口

### 7. TCP的运输连接管理

三个阶段：

1. 连接建立
2. 数据传送
3. 连接释放

#### 1.TCP的连接建立

![用三报文握手建立TCP连接](https://github.com/chenshuaiyu/Notes/blob/master/Network/assets/用三报文握手建立TCP连接.PNG)

| 过程       | 具体描述                                                     | 报文段信息                                                   | 状态                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 第一次握手 | 客户端向服务器发送一个连接请求的报文段                       | 同步标志位 设为1：SYN=1<br />随机选择一个起始序号：seq=x<br />不携带数据<br />（因SYN位被设置为1的报文段不能携带数据，但要消耗一个序号） | 客户端进入 同步已发送 状态（SYN_SEND）<br />（等待服务器的确认） |
| 第二次握手 | 服务器收到请求连接报文段后，若同意建立连接，则向客户端发回连接确认的报文段（为该TCP连接分配TCP缓存、变量） | 同步标志位 设为1：SYN=1<br />确认标记位 设为1：ACK=1<br />随机选择一个起始序号：seq=x<br />确认号字段 设为：ack=x+1<br />不携带数据<br />（因SYN位被设置为1的报文段不能携带数据，但要消耗一个序号） | 服务器进入 同步已接收 状态（SYN_RCVD）                       |
| 第三次握手 | 客户端收到确认报文段后，向服务器再次发出连接确认报文段（为该TCP连接分配TCP缓存、变量） | 确认标记位 设为1：ACK=1<br />序号：seq=x+1<br />确认号字段 设为：ack=y+1<br />可携带数据<br />（因SYN位无设为1，若不携带数据则不消耗序号） | 客户端、服务端都进入 已创建状态（ESTABLISHED）<br />（可开始发送数据） |

#### 2.TCP的连接释放

![TCP连接释放的过程](https://github.com/chenshuaiyu/Notes/blob/master/Network/assets/TCP连接释放的过程.PNG)

| 过程       | 具体描述                                                     | 报文段信息                                                   | 信息                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 第一次挥手 | 客户端向服务端发送一个连接释放的报文段（停止再发送数据）     | 终止控制位 设为1：FIN=1<br />报文段序号 设为前面传送数据最后一个字节的序号加1：seq=u<br />（FIN=1 的报文即使不携带数据也消耗1个序号） | 客户端进入 终止等待1 状态（FIN_WAIT_1）<br />（等待服务器的确认） |
| 第二次挥手 | 服务端收到连接释放报文段后，则向客户端发回连接释放确认的报文段 | 确认标记位 设为1：ACK=1<br />报文段序号 设为前面传送数据最后一个字节的序号加1：seq=v<br />确认号字段 设为：ack=u+1 | 服务器进入 关闭等待 状态（CLOSE_WAIT）<br />客户端收到服务器的确认后，进入终止等待2 状态（FIN_WAIT_2），等待服务器发出释放连接请求<br />至此，客户端->服务端的TCP连接已断开<br />即TCP连接处于半关闭状态<br />即客户端->服务端断开，但服务端->客户端未断开 |
| 第三次挥手 | 如服务器已无向客户端发送数据，则发出释放连接的报文段         | 终止控制位 设为1：FIN=1<br />确认标记位 设为1：ACK=1<br />报文段序列：seq=w<br />重复上次已发送的确认号字段 设为：ack=u+1<br />可携带数据<br />（FIN=1的报文即使不携带数据也消耗1个序号） | 服务端进入 最后确认状态（LAST_ACK）                          |
| 第四次挥手 | 客户端收到连接释放报文段后，则向服务器发回连接释放确认的报文段 | 确认标记位 设为1：ACK=1<br />报文段序号：seq=u+1<br />确认号字段 设为1：ack=w+1<br />可携带数据<br />（FIN=1的报文即使不携带数据也消耗1个序号） | 客户端进入 时间等待状态（TIME_WAIT）<br />服务端进入 关闭状态（CLOSED）<br />此时TCP连接还未释放<br />须经过时间等待计时器设置的时间2MSL后，客户端才进入连接关闭状态<br />即服务器进入关闭状态比客户端要早一些 |

