# 2.对象及变量的并发访问

### 2.1 synchronized同步方法

#### 2.1.1 方法内的变量为线程安全

非线程安全问题存在于实例变量中，如果是方法内部的私有变量，则不存在线程安全，所得的结果也就是线程安全的了。

```java
public class HasSelfPrivateNum {
    public void addI(String username) {
        try {
            int num = 0;
            if (username.equals("a")) {
                num = 100;
                System.out.println("a set over!");
                Thread.sleep(2000);
            } else {
                num = 200;
                System.out.println("b set over");
            }
            System.out.println(username + "num = " + num);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private HasSelfPrivateNum numRef;

    public ThreadA(HasSelfPrivateNum numRef) {
        super();
        this.numRef = numRef;
    }

    @Override
    public void run() {
        super.run();
        numRef.addI("a");
    }
}
```

```java
public class ThreadB extends Thread {
    private HasSelfPrivateNum numRef;

    public ThreadB(HasSelfPrivateNum numRef) {
        super();
        this.numRef = numRef;
    }

    @Override
    public void run() {
        super.run();
        numRef.addI("b");
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        HasSelfPrivateNum numRef = new HasSelfPrivateNum();
        ThreadA athread = new ThreadA(numRef);
        athread.start();
        ThreadB bthread = new ThreadB(numRef);
        bthread.start();
    }
}
```

输出：

有问题。。。

#### 2.1.2 实例变量非线程安全

将`int num = 0;`改为成员变量

输出：

```
a set over!
b set over
b num = 200
a num = 100
```

在addI方法前加上synchronized关键字，

输出：

```
a set over!
a num = 100
b set over
b num = 200
```

在两个线程中访问同一个对象中的同步方法时一定是安全的。本实验由于是同步访问，所以先打印出a，在打印出b。

#### 2.1.3 多个对象多个锁

```java
public class HasSelfPrivateNum {
    private int num = 0;
    public synchronized void addI(String username) {
        try {
            if (username.equals("a")) {
                num = 100;
                System.out.println("a set over!");
                Thread.sleep(2000);
            } else {
                num = 200;
                System.out.println("b set over");
            }
            System.out.println(username + " num = " + num);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private HasSelfPrivateNum numRef;

    public ThreadA(HasSelfPrivateNum numRef) {
        super();
        this.numRef = numRef;
    }

    @Override
    public void run() {
        super.run();
        numRef.addI("a");
    }
}
```

```java
public class ThreadB extends Thread {
    private HasSelfPrivateNum numRef;

    public ThreadB(HasSelfPrivateNum numRef) {
        super();
        this.numRef = numRef;
    }

    @Override
    public void run() {
        super.run();
        numRef.addI("b");
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        HasSelfPrivateNum numRef1 = new HasSelfPrivateNum();
        HasSelfPrivateNum numRef2 = new HasSelfPrivateNum();
        ThreadA athread = new ThreadA(numRef1);
        athread.start();
        ThreadB bthread = new ThreadB(numRef2);
        bthread.start();
    }
}
```

输出：

```
a set over!
b set over
b num = 200
a num = 100
```

效果是以异步的方式运行的。

打印的顺序为什么是交叉的？

关键字synchronized取得的锁都是对象锁，而不是一段代码或方法（函数）当作锁。

多个线程访问多个对象，则JVM会创建多个锁。

#### 2.1.4 synchronized方法与锁对象

为了证明前面的讲述线程锁的是对象，

```java
public class MyObject {
    public void methodA(){
        try {
            System.out.println("begin methodA threadName" + Thread.currentThread().getName());
            Thread.sleep(5000);
            System.out.println("end");
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private MyObject object;

    public ThreadA(MyObject object) {
        super();
        this.object = object;
    }

    @Override
    public void run() {
        super.run();
        object.methodA();
    }
}
```

```java
public class ThreadB extends Thread {
    private MyObject object;

    public ThreadB(MyObject object) {
        super();
        this.object = object;
    }

    @Override
    public void run() {
        super.run();
        object.methodA();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        MyObject object = new MyObject();
        ThreadA a = new ThreadA(object);
        a.setName("A");
        ThreadB b = new ThreadB(object);
        b.setName("B");
        a.start();
        b.start();
    }
}
```

输出：

```
begin methodA threadNameA
begin methodA threadNameB
end
end
```

更改MyObejct，

```java
public class MyObject {
    public synchronized void methodA(){
        try {
            System.out.println("begin methodA threadName" + Thread.currentThread().getName());
            Thread.sleep(5000);
            System.out.println("end");
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}
```

输出：

```
begin methodA threadNameA
end
begin methodA threadNameB
end
```

