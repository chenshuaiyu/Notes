# 2.对象及变量的并发访问

### 2.1 synchronized同步方法

#### 2.1.1 方法内的变量为线程安全

非线程安全问题存在于实例变量中，如果是方法内部的私有变量，则不存在线程安全，所得的结果也就是线程安全的了。

```java
public class HasSelfPrivateNum {
    public void addI(String username) {
        try {
            int num = 0;
            if (username.equals("a")) {
                num = 100;
                System.out.println("a set over!");
                Thread.sleep(2000);
            } else {
                num = 200;
                System.out.println("b set over");
            }
            System.out.println(username + "num = " + num);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private HasSelfPrivateNum numRef;

    public ThreadA(HasSelfPrivateNum numRef) {
        super();
        this.numRef = numRef;
    }

    @Override
    public void run() {
        super.run();
        numRef.addI("a");
    }
}
```

```java
public class ThreadB extends Thread {
    private HasSelfPrivateNum numRef;

    public ThreadB(HasSelfPrivateNum numRef) {
        super();
        this.numRef = numRef;
    }

    @Override
    public void run() {
        super.run();
        numRef.addI("b");
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        HasSelfPrivateNum numRef = new HasSelfPrivateNum();
        ThreadA athread = new ThreadA(numRef);
        athread.start();
        ThreadB bthread = new ThreadB(numRef);
        bthread.start();
    }
}
```

输出：

```
a set over!
b set over
b num = 200
a num = 100
```

#### 2.1.2 实例变量非线程安全

将`int num = 0;`改为成员变量

输出：

```
a set over!
b set over
b num = 200
a num = 200
```

在addI方法前加上synchronized关键字，

输出：

```
a set over!
a num = 100
b set over
b num = 200
```

在两个线程中访问同一个对象中的同步方法时一定是安全的。本实验由于是同步访问，所以先打印出a，在打印出b。

#### 2.1.3 多个对象多个锁

```java
public class HasSelfPrivateNum {
    private int num = 0;
    public synchronized void addI(String username) {
        try {
            if (username.equals("a")) {
                num = 100;
                System.out.println("a set over!");
                Thread.sleep(2000);
            } else {
                num = 200;
                System.out.println("b set over");
            }
            System.out.println(username + " num = " + num);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private HasSelfPrivateNum numRef;

    public ThreadA(HasSelfPrivateNum numRef) {
        super();
        this.numRef = numRef;
    }

    @Override
    public void run() {
        super.run();
        numRef.addI("a");
    }
}
```

```java
public class ThreadB extends Thread {
    private HasSelfPrivateNum numRef;

    public ThreadB(HasSelfPrivateNum numRef) {
        super();
        this.numRef = numRef;
    }

    @Override
    public void run() {
        super.run();
        numRef.addI("b");
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        HasSelfPrivateNum numRef1 = new HasSelfPrivateNum();
        HasSelfPrivateNum numRef2 = new HasSelfPrivateNum();
        ThreadA athread = new ThreadA(numRef1);
        athread.start();
        ThreadB bthread = new ThreadB(numRef2);
        bthread.start();
    }
}
```

输出：

```
a set over!
b set over
b num = 200
a num = 100
```

效果是以异步的方式运行的。

打印的顺序为什么是交叉的？

关键字synchronized取得的锁都是对象锁，而不是一段代码或方法（函数）当作锁。

多个线程访问多个对象，则JVM会创建多个锁。

#### 2.1.4 synchronized方法与锁对象

为了证明前面的讲述线程锁的是对象，

```java
public class MyObject {
    public void methodA(){
        try {
            System.out.println("begin methodA threadName" + Thread.currentThread().getName());
            Thread.sleep(5000);
            System.out.println("end");
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private MyObject object;

    public ThreadA(MyObject object) {
        super();
        this.object = object;
    }

    @Override
    public void run() {
        super.run();
        object.methodA();
    }
}
```

```java
public class ThreadB extends Thread {
    private MyObject object;

    public ThreadB(MyObject object) {
        super();
        this.object = object;
    }

    @Override
    public void run() {
        super.run();
        object.methodA();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        MyObject object = new MyObject();
        ThreadA a = new ThreadA(object);
        a.setName("A");
        ThreadB b = new ThreadB(object);
        b.setName("B");
        a.start();
        b.start();
    }
}
```

输出：

```
begin methodA threadNameA
begin methodA threadNameB
end
end
```

更改MyObejct，

```java
public class MyObject {
    public synchronized void methodA(){
        try {
            System.out.println("begin methodA threadName" + Thread.currentThread().getName());
            Thread.sleep(5000);
            System.out.println("end");
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}
```

输出：

```
begin methodA threadNameA
end
begin methodA threadNameB
end
```

通过上面的实验得到结论，调用关键字synchronized声明的方法一定是排队运行的。只有共享资源的读写访问才需要同步化。

增加一个methodB方法：

```java
public class MyObject {
    public synchronized void methodA(){
        try {
            System.out.println("begin methodA threadName" + Thread.currentThread().getName());
            Thread.sleep(5000);
            System.out.println("end endTime = " + System.currentTimeMillis());
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }

    public void methodB(){
        try {
            System.out.println("begin methodA threadName" + Thread.currentThread().getName() + " begin time" + System.currentTimeMillis());
            Thread.sleep(5000);
            System.out.println("end");
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}
```

输出：

```
begin methodA threadNameA
begin methodA threadNameB begin time1537524635054
end
end endTime = 1537524640055
```

虽然线程A先持有了object的锁，但线程B完全可以异步调用非synchronized类型的方法。

将methodB方法加上synchronized关键字：

```
begin methodA threadNameA
end endTime = 1537524999248
begin methodA threadNameB begin time1537524999248
end
```

结论：

1. A线程先持有object对象的Lock锁，B线程可以以异步的方式调用object对象中的非synchronized类型的方法。
2. A线程先持有object对象的Lock锁，B线程如果在这是调用object对象中的synchronized类型的方法则需等待，也就是同步。

#### 2.1.5 脏读

虽然在赋值时进行了同步，但在取值时有可能出现一些意想不到的意外，这些情况就是脏读（dirtyRead）。发生脏读的情况就是在读取实例变量时，此值已经被其它线程更改过了。

```java
public class PublicVar {
    private String username = "A";
    private String password = "AA";

    public synchronized void setValue(String username, String password) {
        try {
            this.username = username;
            Thread.sleep(5000);
            this.password = password;
            System.out.println("setValue method thread name = " + Thread.currentThread().getName() + " username = " + username + " password = " + password);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void getValue() {
        System.out.println("getValue method thread name = " + Thread.currentThread().getName() + " username = " + username + " password = " + password);
    }
}
```

```java
public class ThreadA extends Thread {
    private PublicVar publicVar;

    public ThreadA(PublicVar publicVar) {
        super();
        this.publicVar = publicVar;
    }

    @Override
    public void run() {
        super.run();
        publicVar.setValue("B","BB");
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        try {
            PublicVar publicVar = new PublicVar();
            ThreadA threadA = new ThreadA(publicVar);
            threadA.start();
            Thread.sleep(200);//打印结果收此值大小的影响
            publicVar.getValue();
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}
```

输出：

```
getValue method thread name = main username = B password = AA
setValue method thread name = Thread-0 username = B password = BB
```

出现脏读就是因为getValue方法并不是同步的，所以可以在任何时候进行调用。解决方法就是加上synchronized关键字。

```java
public synchronized void getValue() {
    System.out.println("getValue method thread name = " + Thread.currentThread().getName() + " username = " + username + " password = " + password);
}
```

输出：

```
setValue method thread name = Thread-0 username = B password = BB
getValue method thread name = main username = B password = BB
```

- 当A线程调用anyObject对象加入synchronized关键字的X方法时，A线程就获得了X方法锁，更准确的地讲，是获得了对象的锁，所以其他线程必须等A线程执行完毕才可以调用X方法，但B线程可以随意调用其他的非synchronized同步方法。
- 当A线程调用anyObject对象加入synchronized关键字的X方法时，A线程就获得了X方法所在对象的锁，所以其他线程必须等A线程执行完毕才可以调用X方法，而B线程如果调用声明了synchronized关键字的非X方法，必须等A线程将X方法执行完，也就是释放完对象锁后才可以调用。这是A线程已经执行完一个完整的任务，也就是说username和password这两个实例变量已经同时被赋值，不存在脏读的接班环境。

脏读一定会出现操作实例变量的情况下，这就是不同线程争抢实例变量的结果。

#### 2.1.6 synchronized锁重入

关键字synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时是可以再次得到该对象的锁的。这也证明在一个synchronized方法/块的内部调用本类的其他synchronized方法/块时，是永远可以得到锁的。

```java
public class Service {
    public synchronized void service1(){
        System.out.println("service1");
        service2();
    }

    private synchronized void service2() {
        System.out.println("service2");
        service3();
    }

    private synchronized void service3() {
        System.out.println("service3");
    }
}
```

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        Service service = new Service();
        service.service1();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();
    }
}
```

输出：

```
service1
service2
service3
```

可重入锁：自己可以再次获取自己的内部锁。

比如有1条线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。

可重入锁也支持在父子类继承的环境中。

```java
public class Main {
    public int i = 10;

    public synchronized void operateIMainMethod(){
        try {
            i--;
            System.out.println("main print i = " + i);
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class Sub extends Main {

    @Override
    public synchronized void operateIMainMethod() {
        try {
            while(i > 0){
                i--;
                System.out.println("sub print i = " + i);
                Thread.sleep(100);
                this.operateIMainMethod();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread extends Thread {

    @Override
    public void run() {
        Sub sub = new Sub();
        sub.operateIMainMethod();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();
    }
}
```

输出：

```
sub print i = 9
main print i = 8
sub print i = 7
main print i = 6
sub print i = 5
main print i = 4
sub print i = 3
main print i = 2
sub print i = 1
main print i = 0
```

当存在父子类继承关系时，子类是完全可以通过可重入锁调用父类的同步方法的。

#### 2.1.7 出现异常，所自动释放

当一个线程执行的代码出现遗产时，其持有的锁会自动释放。

```java
public class Service {
    public synchronized void testMethod() {
        if (Thread.currentThread().getName().equals("a")) {
            System.out.println("ThreadName = " + Thread.currentThread().getName() + "run beginTime = " + System.currentTimeMillis());
            int i = 1;
            while (i == 1) {
                if (("" + Math.random()).subSequence(0,8).equals("0.123456")){
                    System.out.println("ThreadName = " + Thread.currentThread().getName() + "run exception = " + System.currentTimeMillis());
                    Integer.parseInt("a");
                }
            }
        } else {
            System.out.println("Thread B run Time = " + System.currentTimeMillis());
        }
    }
}
```

```java
public class ThreadA extends Thread {

    private Service service;

    public ThreadA(Service service) {
        super();
        this.service = service;
    }

    @Override
    public void run() {
        service.testMethod();
    }
}
```

```java
public class ThreadB extends Thread {

    private Service service;

    public ThreadB(Service service) {
        super();
        this.service = service;
    }

    @Override
    public void run() {
        service.testMethod();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        try {
            Service service = new Service();
            ThreadA a = new ThreadA(service);
            a.setName("a");
            a.start();
            Thread.sleep(500);
            ThreadB b = new ThreadB(service);
            b.setName("b");
            b.start();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

输出：

```
ThreadName = a run beginTime = 1537596651015
ThreadName = a run exception = 1537596651478
Exception in thread "a" java.lang.NumberFormatException: For input string: "a"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at 第2章.throwExceptionNoLock.Service.testMethod(Service.java:16)
	at 第2章.throwExceptionNoLock.ThreadA.run(ThreadA.java:18)
Thread B run Time = 1537596651514
```

线程a出现异常并释放锁，线程b进入方法正常打印，出现异常的锁被释放了。

#### 2.1.8 同步不具有继承性

```java
public class Main {
    public synchronized void serviceMethod(){
        try {
            System.out.println("int main 下一步 sleep begin threadName = " + Thread.currentThread().getName()+ " time = " + System.currentTimeMillis());
            Thread.sleep(5000);
            System.out.println("int main 下一步 sleep end threadName = " + Thread.currentThread().getName()+ " time = " + System.currentTimeMillis());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class Sub extends Main {
    @Override
    public void serviceMethod() {
        try {
            System.out.println("int sub 下一步 sleep begin threadName = " + Thread.currentThread().getName()+ " time = " + System.currentTimeMillis());
            Thread.sleep(5000);
            System.out.println("int sub 下一步 sleep end threadName = " + Thread.currentThread().getName()+ " time = " + System.currentTimeMillis());
            super.serviceMethod();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThreadA extends Thread {

    private Sub sub;

    public MyThreadA(Sub sub) {
        super();
        this.sub = sub;
    }

    @Override
    public void run() {
        sub.serviceMethod();
    }
}
```

```java
public class MyThreadB extends Thread {

    private Sub sub;

    public MyThreadB(Sub sub) {
        super();
        this.sub = sub;
    }

    @Override
    public void run() {
        sub.serviceMethod();
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Sub subRef = new Sub();
        MyThreadA a = new MyThreadA(subRef);
        a.setName("A");
        a.start();
        MyThreadB b = new MyThreadB(subRef);
        b.setName("B");
        b.start();
    }
}
```

输出：

```
int sub 下一步 sleep begin threadName = A time = 1537597282925
int sub 下一步 sleep begin threadName = B time = 1537597282925
int sub 下一步 sleep end threadName = B time = 1537597287925
int sub 下一步 sleep end threadName = A time = 1537597287925
int main 下一步 sleep begin threadName = B time = 1537597287925
int main 下一步 sleep end threadName = B time = 1537597292925
int main 下一步 sleep begin threadName = A time = 1537597292925
int main 下一步 sleep end threadName = A time = 1537597297926
```

前两句为非同步调用。

在子类的方法中添加synchronized关键字。

```
int sub 下一步 sleep begin threadName = A time = 1537597522178
int sub 下一步 sleep end threadName = A time = 1537597527179
int main 下一步 sleep begin threadName = A time = 1537597527179
int main 下一步 sleep end threadName = A time = 1537597532179
int sub 下一步 sleep begin threadName = B time = 1537597532179
int sub 下一步 sleep end threadName = B time = 1537597537180
int main 下一步 sleep begin threadName = B time = 1537597537180
int main 下一步 sleep end threadName = B time = 1537597542181
```

### 2.2 synchronized同步语句块

用synchronized声明方法在某种情况下是有弊端的，比如A线程调用同步方法执行一个长时间的任务，那么B线程则必须比较长的时间。在这种晴情况下可以使用synchronized同步语句块来解决。

#### 2.2.1 synchronized方法的弊端

```java
public class Task {
    private String getData1;
    private String getData2;
    public synchronized void doLongTimeTask(){
        try {
            System.out.println("begin task");
            Thread.sleep(3000);
            getData1 = "长时间处理任务后从远程返回的值 1 threadName = " + Thread.currentThread().getName();
            getData2 = "长时间处理任务后从远程返回的值 2 threadName = " + Thread.currentThread().getName();
            System.out.println(getData1);
            System.out.println(getData2);
            System.out.println("end task");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class CommonUtils {
    public static long beginTime1;
    public static long endTime1;
    public static long beginTime2;
    public static long endTime2;
}
```

```java
public class MyThread1 extends Thread {
    private Task task;

    public MyThread1(Task task) {
        this.task = task;
    }

    @Override
    public void run() {
        super.run();
        CommonUtils.beginTime1 = System.currentTimeMillis();
        task.doLongTimeTask();
        CommonUtils.endTime1 = System.currentTimeMillis();
    }
}
```

```java
public class MyThread2 extends Thread {
    private Task task;

    public MyThread2(Task task) {
        this.task = task;
    }

    @Override
    public void run() {
        super.run();
        CommonUtils.beginTime2 = System.currentTimeMillis();
        task.doLongTimeTask();
        CommonUtils.endTime2 = System.currentTimeMillis();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        Task task = new Task();
        MyThread1 thread1 = new MyThread1(task);
        thread1.start();
        MyThread2 thread2 = new MyThread2(task);
        thread2.start();
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        long beginTime = CommonUtils.beginTime1;
        if (CommonUtils.beginTime2 < CommonUtils.beginTime1){
            beginTime = CommonUtils.beginTime2;
        }
        long endTime = CommonUtils.endTime1;
        if (CommonUtils.endTime2 > CommonUtils.endTime1){
            endTime = CommonUtils.endTime2;
        }
        System.out.println("耗时：" + ((endTime - beginTime) / 1000));
    }
}
```

输出：

```
begin task
长时间处理任务后从远程返回的值 1 threadName = Thread-0
长时间处理任务后从远程返回的值 2 threadName = Thread-0
end task
begin task
长时间处理任务后从远程返回的值 1 threadName = Thread-1
长时间处理任务后从远程返回的值 2 threadName = Thread-1
end task
耗时：6
```

#### 2.2.2 synchronized同步代码块的使用

当两个并发线程访问同一个对象object中的synchronized(this)同步代码块时，一段时间内能有一个线程被执行，另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。

```java
public class ObjectService {
    public void serviceMethod(){
        try {
            synchronized (this){
                System.out.println("begin time = " + System.currentTimeMillis());
                Thread.sleep(2000);
                System.out.println("end end = " + System.currentTimeMillis());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class ThreadA extends Thread{

    private ObjectService service;

    public ThreadA(ObjectService service) {
        this.service = service;
    }

    @Override
    public void run() {
        super.run();
        service.serviceMethod();
    }
}
```

```java
public class ThreadB extends Thread{

    private ObjectService service;

    public ThreadB(ObjectService service) {
        this.service = service;
    }

    @Override
    public void run() {
        super.run();
        service.serviceMethod();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        ObjectService service = new ObjectService();
        ThreadA a = new ThreadA(service);
        a.setName("a");
        a.start();
        ThreadB b = new ThreadB(service);
        b.setName("b");
        b.start();
    }
}
```

虽然使用了synchronized同步代码块，但执行的效率还是没有提高，执行的效果还是同步运行的。

#### 2.2.3 用同步代码块解决同步方法的弊端

修改Task，

```java
public class Task {
    private String getData1;
    private String getData2;
    public void doLongTimeTask(){
        try {
            System.out.println("begin task");
            Thread.sleep(3000);
            String privateGetData1 = "长时间处理任务后从远程返回的值 1 threadName = " + Thread.currentThread().getName();
            String privateGetData2 = "长时间处理任务后从远程返回的值 2 threadName = " + Thread.currentThread().getName();

            synchronized (this){
                getData1 = privateGetData1;
                getData2 = privateGetData2;
            }

            System.out.println(getData1);
            System.out.println(getData2);
            System.out.println("end task");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

输出：

```
begin task
begin task
长时间处理任务后从远程返回的值 1 threadName = Thread-1
长时间处理任务后从远程返回的值 2 threadName = Thread-0
end task
长时间处理任务后从远程返回的值 1 threadName = Thread-0
长时间处理任务后从远程返回的值 2 threadName = Thread-0
end task
耗时：3
```

通过上面可以得知，当一个线程访问object的一个synchronized同步代码块时，另一个线程仍然可以访问该object对象中非synchronized(this)同步代码块。

#### 2.2.4 一半同步，一半异步

不在synchronized块中就是异步执行，在synchronized块中就是同步执行。

```java
public class Task {
    public void doLongTimeTask() {
        for (int i = 0; i < 100; i++) {
            System.out.println("nosynchronzied threadName = " + Thread.currentThread().getName() + " i = " + (i + 1));
        }
        System.out.println("");
        synchronized (this) {
            for (int i = 0; i < 100; i++) {
                System.out.println("synchronzied threadName = " + Thread.currentThread().getName() + " i = " + (i + 1));
            }
        }
    }
}
```

```java
public class MyThread1 extends Thread {
    private Task task;

    public MyThread1(Task task) {
        this.task = task;
    }

    @Override
    public void run() {
        super.run();
        task.doLongTimeTask();
    }
}
```

```java
public class MyThread2 extends Thread {
    private Task task;

    public MyThread2(Task task) {
        this.task = task;
    }

    @Override
    public void run() {
        super.run();
        task.doLongTimeTask();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        Task task = new Task();
        MyThread1 thread1 = new MyThread1(task);
        thread1.start();
        MyThread2 thread2 = new MyThread2(task);
        thread2.start();
    }
}
```

#### 2.2.5 synchronized代码块间的同步性

在使用synchronized(this)代码块时需要注意的是，当一个线程访问object的一个synchronized(this)同步代码块时，其它线程对同一个object中所有其他synchronized(this)同步代码块的访问被阻塞，这说明synchronized使用的**对象监视器**是一个。

```java
public class ObjectService {
    public void serviceMethodA(){
        try {
            synchronized (this){
                System.out.println("A begin time = " + System.currentTimeMillis());
                Thread.sleep(2000);
                System.out.println("A end end = " + System.currentTimeMillis());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void serviceMethodB(){
        synchronized (this){
            System.out.println("B begin time = " + System.currentTimeMillis());
            System.out.println("B end end = " + System.currentTimeMillis());
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private ObjectService service;

    public ThreadA(ObjectService service) {
        super();
        this.service = service;
    }

    @Override
    public void run() {
        super.run();
        service.serviceMethodA();
    }
}
```

```java
public class ThreadB extends Thread {
    private ObjectService service;

    public ThreadB(ObjectService service) {
        super();
        this.service = service;
    }

    @Override
    public void run() {
        super.run();
        service.serviceMethodB();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        ObjectService service = new ObjectService();
        ThreadA a = new ThreadA(service);
        a.setName("a");
        a.start();
        ThreadB b = new ThreadB(service);
        b.setName("b");
        b.start();
    }
}
```

输出：

```
A begin time = 1537601670607
A end end = 1537601672607
B begin time = 1537601672607
B end end = 1537601672607
```

#### 2.2.6 验证同步synchronized(this)代码块时锁定当前对象的

和synchronized方法一样，synchronized(this)代码块也是锁定当前对象的。

```java
public class Task {
    public void otherMethod() {
        System.out.println("-------------run--otherMethod");
    }
    public void doLongTimeTask(){
        synchronized (this){
            for (int i = 0; i < 10000; i++) {
                System.out.println("synchronized threadName = " + Thread.currentThread().getName() + " i = " + (i + 1));
            }
        }
    }
}
```

```java
public class MyThread1 extends Thread {
    private Task task;

    public MyThread1(Task task) {
        super();
        this.task = task;
    }

    @Override
    public void run() {
        super.run();
        task.doLongTimeTask();
    }
}
```

```java
public class MyThread2 extends Thread {
    private Task task;

    public MyThread2(Task task) {
        super();
        this.task = task;
    }

    @Override
    public void run() {
        super.run();
        task.otherMethod();
    }
}
```

输出：

```
...
synchronized threadName = Thread-0 i = 383
synchronized threadName = Thread-0 i = 384
-------------run--otherMethod
synchronized threadName = Thread-0 i = 385
synchronized threadName = Thread-0 i = 386
...
```

异步打印。

更改Task，将otherMethod更改为synchronized方法。

```
...
synchronized threadName = Thread-0 i = 9999
synchronized threadName = Thread-0 i = 10000
-------------run--otherMethod
```

同步打印。

#### 2.2.7 将任意对象作为对象监视器

多个线程调用同一对象中的不同名称的synchronized同步方法或synchronized(this)同步代码块时，调用的效果就是按顺序执行，也就是同步的，阻塞的。

























