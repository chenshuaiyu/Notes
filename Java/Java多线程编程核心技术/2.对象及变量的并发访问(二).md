# 2.对象及变量的并发访问(二)

### 2.3 volatile关键字

关键字volatile的主要作用是使多个变量在多个线程间可见。

#### 2.3.1 关键字volatile与死循环

```java
public class PrintString {
    private boolean isContinuePrint = true;

    public boolean isContinuePrint() {
        return isContinuePrint;
    }

    public void setContinuePrint(boolean continuePrint) {
        isContinuePrint = continuePrint;
    }
    public void printStringMethod() {
        try {
            while(isContinuePrint != true) {
                System.out.println("run printStringMethod threadName = " + Thread.currentThread().getName());
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        PrintString printStringService = new PrintString();
        printStringService.printStringMethod();
        System.out.println("我要停止它！ stopThread = " + Thread.currentThread().getName());
        printStringService.setContinuePrint(false);
    }
}
```

输出：

```
run printStringMethod threadName = main
run printStringMethod threadName = main
...
```

程序根本停不下来。

原因：main线程一直在处理while()循环，导致程序不能执行后面的代码。

#### 2.3.2 解决同步死循环

```java
public class PrintString implements Runnable {
    private boolean isContinuePrint = true;

    public boolean isContinuePrint() {
        return isContinuePrint;
    }

    public void setContinuePrint(boolean continuePrint) {
        isContinuePrint = continuePrint;
    }
    public void printStringMethod() {
        try {
            while(isContinuePrint == true) {
                System.out.println("run printStringMethod threadName = " + Thread.currentThread().getName());
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void run() {
        printStringMethod();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        PrintString printStringService = new PrintString();
        new Thread(printStringService).start();
        System.out.println("我要停止它！ stopThread = " + Thread.currentThread().getName());
        printStringService.setContinuePrint(false);
    }
}
```

输出：

```
我要停止它！ stopThread = main
```

关键字volatile的作用是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值。

#### 2.3.3 解决异步死循环

```java
public class RunThread extends Thread {
    private boolean isRunning = true;

    public boolean isRunning() {
        return isRunning;
    }

    public void setRunning(boolean running) {
        isRunning = running;
    }

    @Override
    public void run() {
        System.out.println("进入run了");
        while (isRunning == true) {
        }
        System.out.println("线程被停止了！");
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        try {
            RunThread thread = new RunThread();
            thread.start();
            Thread.sleep(1000);
            thread.setRunning(false);
            System.out.println("已经赋值为false");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

输出：

```
进入run了
已经赋值为false

```

进入死循环。

原因：

在启动RunThread线程时，变量`private boolean isRunning = true;`存在于公共堆栈及线程的私有堆栈中，线程一直在堆栈中取得isRunning的值是true。而代码`thread.setRunning(false);`虽然被执行，更新的却是公共堆栈中的isRunning的变量值false，所以一直是死循环的状态。

这个问题其实就是私有堆栈中的值和公共堆栈中的值不同步造成的。解决这样的问题就要使用volatile关键字了，它的主要作用就是当线程访问isRunning这个变量时，强制性从公共堆栈中进行取值。

```java
public class RunThread extends Thread {
    volatile private boolean isRunning = true;

    public boolean isRunning() {
        return isRunning;
    }

    public void setRunning(boolean running) {
        isRunning = running;
    }

    @Override
    public void run() {
        System.out.println("进入run了");
        while (isRunning == true) {
        }
        System.out.println("线程被停止了！");
    }
}
```

输出：

```
进入run了
已经赋值为false
线程被停止了！
```

使用volatile关键字增加了实例变量在多个线程之间的可读性。但volatile关键字最致命的缺点是不支持原子性。

关键字synchronzied和volatile进行比较：

1. 关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronzied性能要好，并且volatile只能修饰与变量，而synchronzied可以修饰方法，以及代码块。随着JDK新版本的发布，synchronzied关键字在效率上得到了很大提升，在开发中使用synchronzied关键字的比率还是比较大的。
2. 多线程访问volatile不会发生阻塞，而synchronzied会出现阻塞。
3. volatile能保证数据的可见性，但不能保证原子性，而synchronzied就可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步。
4. 关键字volatile解决的是变量在多个线程之间的可见性，而synchronzied关键字解决的是多个线程之间访问资源的同步性。

#### 2.3.4 volatile非原子的特性

关键字volatile增加了实例变量间在多个线程之间的可见性，但它不具备同步性，那么也就不具备原子性。

```java
public class MyThread extends Thread {
    volatile public static int count;

    private static void addCount() {
        for (int i = 0; i < 100; i++) {
            count++;
        }
        System.out.println("count = " + count);
    }

    @Override
    public void run() {
        addCount();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        MyThread[] myThreadArray = new MyThread[100];
        for (int i = 0; i < 100; i++) {
            myThreadArray[i] = new MyThread();
        }
        for (int i = 0; i < 100; i++) {
            myThreadArray[i].start();
        }
    }
}
```

输出：

```
...
count = 9542
count = 9442
```

更改自定义线程类myThread，加synchronized关键字

```java
public class MyThread extends Thread {
    volatile public static int count;

    private synchronized static void addCount() {
        for (int i = 0; i < 100; i++) {
            count++;
        }
        System.out.println("count = " + count);
    }

    @Override
    public void run() {
        addCount();
    }
}
```

输出：

```
...
count = 9900
count = 10000
```

























