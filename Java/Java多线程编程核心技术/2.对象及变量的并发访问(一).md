# 2.对象及变量的并发访问(一)

### 2.1 synchronized同步方法

#### 2.1.1 方法内的变量为线程安全

非线程安全问题存在于实例变量中，如果是方法内部的私有变量，则不存在线程安全，所得的结果也就是线程安全的了。

```java
public class HasSelfPrivateNum {
    public void addI(String username) {
        try {
            int num = 0;
            if (username.equals("a")) {
                num = 100;
                System.out.println("a set over!");
                Thread.sleep(2000);
            } else {
                num = 200;
                System.out.println("b set over");
            }
            System.out.println(username + "num = " + num);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private HasSelfPrivateNum numRef;

    public ThreadA(HasSelfPrivateNum numRef) {
        super();
        this.numRef = numRef;
    }

    @Override
    public void run() {
        super.run();
        numRef.addI("a");
    }
}
```

```java
public class ThreadB extends Thread {
    private HasSelfPrivateNum numRef;

    public ThreadB(HasSelfPrivateNum numRef) {
        super();
        this.numRef = numRef;
    }

    @Override
    public void run() {
        super.run();
        numRef.addI("b");
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        HasSelfPrivateNum numRef = new HasSelfPrivateNum();
        ThreadA athread = new ThreadA(numRef);
        athread.start();
        ThreadB bthread = new ThreadB(numRef);
        bthread.start();
    }
}
```

输出：

```
a set over!
b set over
b num = 200
a num = 100
```

#### 2.1.2 实例变量非线程安全

将`int num = 0;`改为成员变量

输出：

```
a set over!
b set over
b num = 200
a num = 200
```

在addI方法前加上synchronized关键字，

输出：

```
a set over!
a num = 100
b set over
b num = 200
```

在两个线程中访问同一个对象中的同步方法时一定是安全的。本实验由于是同步访问，所以先打印出a，在打印出b。

#### 2.1.3 多个对象多个锁

```java
public class HasSelfPrivateNum {
    private int num = 0;
    public synchronized void addI(String username) {
        try {
            if (username.equals("a")) {
                num = 100;
                System.out.println("a set over!");
                Thread.sleep(2000);
            } else {
                num = 200;
                System.out.println("b set over");
            }
            System.out.println(username + " num = " + num);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private HasSelfPrivateNum numRef;

    public ThreadA(HasSelfPrivateNum numRef) {
        super();
        this.numRef = numRef;
    }

    @Override
    public void run() {
        super.run();
        numRef.addI("a");
    }
}
```

```java
public class ThreadB extends Thread {
    private HasSelfPrivateNum numRef;

    public ThreadB(HasSelfPrivateNum numRef) {
        super();
        this.numRef = numRef;
    }

    @Override
    public void run() {
        super.run();
        numRef.addI("b");
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        HasSelfPrivateNum numRef1 = new HasSelfPrivateNum();
        HasSelfPrivateNum numRef2 = new HasSelfPrivateNum();
        ThreadA athread = new ThreadA(numRef1);
        athread.start();
        ThreadB bthread = new ThreadB(numRef2);
        bthread.start();
    }
}
```

输出：

```
a set over!
b set over
b num = 200
a num = 100
```

效果是以异步的方式运行的。

打印的顺序为什么是交叉的？

关键字synchronized取得的锁都是对象锁，而不是一段代码或方法（函数）当作锁。

多个线程访问多个对象，则JVM会创建多个锁。

#### 2.1.4 synchronized方法与锁对象

为了证明前面的讲述线程锁的是对象，

```java
public class MyObject {
    public void methodA(){
        try {
            System.out.println("begin methodA threadName" + Thread.currentThread().getName());
            Thread.sleep(5000);
            System.out.println("end");
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private MyObject object;

    public ThreadA(MyObject object) {
        super();
        this.object = object;
    }

    @Override
    public void run() {
        super.run();
        object.methodA();
    }
}
```

```java
public class ThreadB extends Thread {
    private MyObject object;

    public ThreadB(MyObject object) {
        super();
        this.object = object;
    }

    @Override
    public void run() {
        super.run();
        object.methodA();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        MyObject object = new MyObject();
        ThreadA a = new ThreadA(object);
        a.setName("A");
        ThreadB b = new ThreadB(object);
        b.setName("B");
        a.start();
        b.start();
    }
}
```

输出：

```
begin methodA threadNameA
begin methodA threadNameB
end
end
```

更改MyObejct，

```java
public class MyObject {
    public synchronized void methodA(){
        try {
            System.out.println("begin methodA threadName" + Thread.currentThread().getName());
            Thread.sleep(5000);
            System.out.println("end");
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}
```

输出：

```
begin methodA threadNameA
end
begin methodA threadNameB
end
```

通过上面的实验得到结论，调用关键字synchronized声明的方法一定是排队运行的。只有共享资源的读写访问才需要同步化。

增加一个methodB方法：

```java
public class MyObject {
    public synchronized void methodA(){
        try {
            System.out.println("begin methodA threadName" + Thread.currentThread().getName());
            Thread.sleep(5000);
            System.out.println("end endTime = " + System.currentTimeMillis());
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }

    public void methodB(){
        try {
            System.out.println("begin methodA threadName" + Thread.currentThread().getName() + " begin time" + System.currentTimeMillis());
            Thread.sleep(5000);
            System.out.println("end");
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}
```

输出：

```
begin methodA threadNameA
begin methodA threadNameB begin time1537524635054
end
end endTime = 1537524640055
```

虽然线程A先持有了object的锁，但线程B完全可以异步调用非synchronized类型的方法。

将methodB方法加上synchronized关键字：

```
begin methodA threadNameA
end endTime = 1537524999248
begin methodA threadNameB begin time1537524999248
end
```

结论：

1. A线程先持有object对象的Lock锁，B线程可以以异步的方式调用object对象中的非synchronized类型的方法。
2. A线程先持有object对象的Lock锁，B线程如果在这是调用object对象中的synchronized类型的方法则需等待，也就是同步。

#### 2.1.5 脏读

虽然在赋值时进行了同步，但在取值时有可能出现一些意想不到的意外，这些情况就是脏读（dirtyRead）。发生脏读的情况就是在读取实例变量时，此值已经被其它线程更改过了。

```java
public class PublicVar {
    private String username = "A";
    private String password = "AA";

    public synchronized void setValue(String username, String password) {
        try {
            this.username = username;
            Thread.sleep(5000);
            this.password = password;
            System.out.println("setValue method thread name = " + Thread.currentThread().getName() + " username = " + username + " password = " + password);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void getValue() {
        System.out.println("getValue method thread name = " + Thread.currentThread().getName() + " username = " + username + " password = " + password);
    }
}
```

```java
public class ThreadA extends Thread {
    private PublicVar publicVar;

    public ThreadA(PublicVar publicVar) {
        super();
        this.publicVar = publicVar;
    }

    @Override
    public void run() {
        super.run();
        publicVar.setValue("B","BB");
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        try {
            PublicVar publicVar = new PublicVar();
            ThreadA threadA = new ThreadA(publicVar);
            threadA.start();
            Thread.sleep(200);//打印结果收此值大小的影响
            publicVar.getValue();
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}
```

输出：

```
getValue method thread name = main username = B password = AA
setValue method thread name = Thread-0 username = B password = BB
```

出现脏读就是因为getValue方法并不是同步的，所以可以在任何时候进行调用。解决方法就是加上synchronized关键字。

```java
public synchronized void getValue() {
    System.out.println("getValue method thread name = " + Thread.currentThread().getName() + " username = " + username + " password = " + password);
}
```

输出：

```
setValue method thread name = Thread-0 username = B password = BB
getValue method thread name = main username = B password = BB
```

- 当A线程调用anyObject对象加入synchronized关键字的X方法时，A线程就获得了X方法锁，更准确的地讲，是获得了对象的锁，所以其他线程必须等A线程执行完毕才可以调用X方法，但B线程可以随意调用其他的非synchronized同步方法。
- 当A线程调用anyObject对象加入synchronized关键字的X方法时，A线程就获得了X方法所在对象的锁，所以其他线程必须等A线程执行完毕才可以调用X方法，而B线程如果调用声明了synchronized关键字的非X方法，必须等A线程将X方法执行完，也就是释放完对象锁后才可以调用。这是A线程已经执行完一个完整的任务，也就是说username和password这两个实例变量已经同时被赋值，不存在脏读的接班环境。

脏读一定会出现操作实例变量的情况下，这就是不同线程争抢实例变量的结果。

#### 2.1.6 synchronized锁重入

关键字synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时是可以再次得到该对象的锁的。这也证明在一个synchronized方法/块的内部调用本类的其他synchronized方法/块时，是永远可以得到锁的。

```java
public class Service {
    public synchronized void service1(){
        System.out.println("service1");
        service2();
    }

    private synchronized void service2() {
        System.out.println("service2");
        service3();
    }

    private synchronized void service3() {
        System.out.println("service3");
    }
}
```

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        Service service = new Service();
        service.service1();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();
    }
}
```

输出：

```
service1
service2
service3
```

可重入锁：自己可以再次获取自己的内部锁。

比如有1条线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。

可重入锁也支持在父子类继承的环境中。

```java
public class Main {
    public int i = 10;

    public synchronized void operateIMainMethod(){
        try {
            i--;
            System.out.println("main print i = " + i);
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class Sub extends Main {

    @Override
    public synchronized void operateIMainMethod() {
        try {
            while(i > 0){
                i--;
                System.out.println("sub print i = " + i);
                Thread.sleep(100);
                this.operateIMainMethod();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThread extends Thread {

    @Override
    public void run() {
        Sub sub = new Sub();
        sub.operateIMainMethod();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();
    }
}
```

输出：

```
sub print i = 9
main print i = 8
sub print i = 7
main print i = 6
sub print i = 5
main print i = 4
sub print i = 3
main print i = 2
sub print i = 1
main print i = 0
```

当存在父子类继承关系时，子类是完全可以通过可重入锁调用父类的同步方法的。

#### 2.1.7 出现异常，所自动释放

当一个线程执行的代码出现遗产时，其持有的锁会自动释放。

```java
public class Service {
    public synchronized void testMethod() {
        if (Thread.currentThread().getName().equals("a")) {
            System.out.println("ThreadName = " + Thread.currentThread().getName() + "run beginTime = " + System.currentTimeMillis());
            int i = 1;
            while (i == 1) {
                if (("" + Math.random()).subSequence(0,8).equals("0.123456")){
                    System.out.println("ThreadName = " + Thread.currentThread().getName() + "run exception = " + System.currentTimeMillis());
                    Integer.parseInt("a");
                }
            }
        } else {
            System.out.println("Thread B run Time = " + System.currentTimeMillis());
        }
    }
}
```

```java
public class ThreadA extends Thread {

    private Service service;

    public ThreadA(Service service) {
        super();
        this.service = service;
    }

    @Override
    public void run() {
        service.testMethod();
    }
}
```

```java
public class ThreadB extends Thread {

    private Service service;

    public ThreadB(Service service) {
        super();
        this.service = service;
    }

    @Override
    public void run() {
        service.testMethod();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        try {
            Service service = new Service();
            ThreadA a = new ThreadA(service);
            a.setName("a");
            a.start();
            Thread.sleep(500);
            ThreadB b = new ThreadB(service);
            b.setName("b");
            b.start();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

输出：

```
ThreadName = a run beginTime = 1537596651015
ThreadName = a run exception = 1537596651478
Exception in thread "a" java.lang.NumberFormatException: For input string: "a"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at 第2章.throwExceptionNoLock.Service.testMethod(Service.java:16)
	at 第2章.throwExceptionNoLock.ThreadA.run(ThreadA.java:18)
Thread B run Time = 1537596651514
```

线程a出现异常并释放锁，线程b进入方法正常打印，出现异常的锁被释放了。

#### 2.1.8 同步不具有继承性

```java
public class Main {
    public synchronized void serviceMethod(){
        try {
            System.out.println("int main 下一步 sleep begin threadName = " + Thread.currentThread().getName()+ " time = " + System.currentTimeMillis());
            Thread.sleep(5000);
            System.out.println("int main 下一步 sleep end threadName = " + Thread.currentThread().getName()+ " time = " + System.currentTimeMillis());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class Sub extends Main {
    @Override
    public void serviceMethod() {
        try {
            System.out.println("int sub 下一步 sleep begin threadName = " + Thread.currentThread().getName()+ " time = " + System.currentTimeMillis());
            Thread.sleep(5000);
            System.out.println("int sub 下一步 sleep end threadName = " + Thread.currentThread().getName()+ " time = " + System.currentTimeMillis());
            super.serviceMethod();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class MyThreadA extends Thread {

    private Sub sub;

    public MyThreadA(Sub sub) {
        super();
        this.sub = sub;
    }

    @Override
    public void run() {
        sub.serviceMethod();
    }
}
```

```java
public class MyThreadB extends Thread {

    private Sub sub;

    public MyThreadB(Sub sub) {
        super();
        this.sub = sub;
    }

    @Override
    public void run() {
        sub.serviceMethod();
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        Sub subRef = new Sub();
        MyThreadA a = new MyThreadA(subRef);
        a.setName("A");
        a.start();
        MyThreadB b = new MyThreadB(subRef);
        b.setName("B");
        b.start();
    }
}
```

输出：

```
int sub 下一步 sleep begin threadName = A time = 1537597282925
int sub 下一步 sleep begin threadName = B time = 1537597282925
int sub 下一步 sleep end threadName = B time = 1537597287925
int sub 下一步 sleep end threadName = A time = 1537597287925
int main 下一步 sleep begin threadName = B time = 1537597287925
int main 下一步 sleep end threadName = B time = 1537597292925
int main 下一步 sleep begin threadName = A time = 1537597292925
int main 下一步 sleep end threadName = A time = 1537597297926
```

前两句为非同步调用。

在子类的方法中添加synchronized关键字。

```
int sub 下一步 sleep begin threadName = A time = 1537597522178
int sub 下一步 sleep end threadName = A time = 1537597527179
int main 下一步 sleep begin threadName = A time = 1537597527179
int main 下一步 sleep end threadName = A time = 1537597532179
int sub 下一步 sleep begin threadName = B time = 1537597532179
int sub 下一步 sleep end threadName = B time = 1537597537180
int main 下一步 sleep begin threadName = B time = 1537597537180
int main 下一步 sleep end threadName = B time = 1537597542181
```

### 2.2 synchronized同步语句块

用synchronized声明方法在某种情况下是有弊端的，比如A线程调用同步方法执行一个长时间的任务，那么B线程则必须比较长的时间。在这种晴情况下可以使用synchronized同步语句块来解决。

#### 2.2.1 synchronized方法的弊端

```java
public class Task {
    private String getData1;
    private String getData2;
    public synchronized void doLongTimeTask(){
        try {
            System.out.println("begin task");
            Thread.sleep(3000);
            getData1 = "长时间处理任务后从远程返回的值 1 threadName = " + Thread.currentThread().getName();
            getData2 = "长时间处理任务后从远程返回的值 2 threadName = " + Thread.currentThread().getName();
            System.out.println(getData1);
            System.out.println(getData2);
            System.out.println("end task");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class CommonUtils {
    public static long beginTime1;
    public static long endTime1;
    public static long beginTime2;
    public static long endTime2;
}
```

```java
public class MyThread1 extends Thread {
    private Task task;

    public MyThread1(Task task) {
        this.task = task;
    }

    @Override
    public void run() {
        super.run();
        CommonUtils.beginTime1 = System.currentTimeMillis();
        task.doLongTimeTask();
        CommonUtils.endTime1 = System.currentTimeMillis();
    }
}
```

```java
public class MyThread2 extends Thread {
    private Task task;

    public MyThread2(Task task) {
        this.task = task;
    }

    @Override
    public void run() {
        super.run();
        CommonUtils.beginTime2 = System.currentTimeMillis();
        task.doLongTimeTask();
        CommonUtils.endTime2 = System.currentTimeMillis();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        Task task = new Task();
        MyThread1 thread1 = new MyThread1(task);
        thread1.start();
        MyThread2 thread2 = new MyThread2(task);
        thread2.start();
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        long beginTime = CommonUtils.beginTime1;
        if (CommonUtils.beginTime2 < CommonUtils.beginTime1){
            beginTime = CommonUtils.beginTime2;
        }
        long endTime = CommonUtils.endTime1;
        if (CommonUtils.endTime2 > CommonUtils.endTime1){
            endTime = CommonUtils.endTime2;
        }
        System.out.println("耗时：" + ((endTime - beginTime) / 1000));
    }
}
```

输出：

```
begin task
长时间处理任务后从远程返回的值 1 threadName = Thread-0
长时间处理任务后从远程返回的值 2 threadName = Thread-0
end task
begin task
长时间处理任务后从远程返回的值 1 threadName = Thread-1
长时间处理任务后从远程返回的值 2 threadName = Thread-1
end task
耗时：6
```

#### 2.2.2 synchronized同步代码块的使用

当两个并发线程访问同一个对象object中的synchronized(this)同步代码块时，一段时间内能有一个线程被执行，另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。

```java
public class ObjectService {
    public void serviceMethod(){
        try {
            synchronized (this){
                System.out.println("begin time = " + System.currentTimeMillis());
                Thread.sleep(2000);
                System.out.println("end end = " + System.currentTimeMillis());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class ThreadA extends Thread{

    private ObjectService service;

    public ThreadA(ObjectService service) {
        this.service = service;
    }

    @Override
    public void run() {
        super.run();
        service.serviceMethod();
    }
}
```

```java
public class ThreadB extends Thread{

    private ObjectService service;

    public ThreadB(ObjectService service) {
        this.service = service;
    }

    @Override
    public void run() {
        super.run();
        service.serviceMethod();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        ObjectService service = new ObjectService();
        ThreadA a = new ThreadA(service);
        a.setName("a");
        a.start();
        ThreadB b = new ThreadB(service);
        b.setName("b");
        b.start();
    }
}
```

虽然使用了synchronized同步代码块，但执行的效率还是没有提高，执行的效果还是同步运行的。

#### 2.2.3 用同步代码块解决同步方法的弊端

修改Task，

```java
public class Task {
    private String getData1;
    private String getData2;
    public void doLongTimeTask(){
        try {
            System.out.println("begin task");
            Thread.sleep(3000);
            String privateGetData1 = "长时间处理任务后从远程返回的值 1 threadName = " + Thread.currentThread().getName();
            String privateGetData2 = "长时间处理任务后从远程返回的值 2 threadName = " + Thread.currentThread().getName();

            synchronized (this){
                getData1 = privateGetData1;
                getData2 = privateGetData2;
            }

            System.out.println(getData1);
            System.out.println(getData2);
            System.out.println("end task");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

输出：

```
begin task
begin task
长时间处理任务后从远程返回的值 1 threadName = Thread-1
长时间处理任务后从远程返回的值 2 threadName = Thread-0
end task
长时间处理任务后从远程返回的值 1 threadName = Thread-0
长时间处理任务后从远程返回的值 2 threadName = Thread-0
end task
耗时：3
```

通过上面可以得知，当一个线程访问object的一个synchronized同步代码块时，另一个线程仍然可以访问该object对象中非synchronized(this)同步代码块。

#### 2.2.4 一半同步，一半异步

不在synchronized块中就是异步执行，在synchronized块中就是同步执行。

```java
public class Task {
    public void doLongTimeTask() {
        for (int i = 0; i < 100; i++) {
            System.out.println("nosynchronzied threadName = " + Thread.currentThread().getName() + " i = " + (i + 1));
        }
        System.out.println("");
        synchronized (this) {
            for (int i = 0; i < 100; i++) {
                System.out.println("synchronzied threadName = " + Thread.currentThread().getName() + " i = " + (i + 1));
            }
        }
    }
}
```

```java
public class MyThread1 extends Thread {
    private Task task;

    public MyThread1(Task task) {
        this.task = task;
    }

    @Override
    public void run() {
        super.run();
        task.doLongTimeTask();
    }
}
```

```java
public class MyThread2 extends Thread {
    private Task task;

    public MyThread2(Task task) {
        this.task = task;
    }

    @Override
    public void run() {
        super.run();
        task.doLongTimeTask();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        Task task = new Task();
        MyThread1 thread1 = new MyThread1(task);
        thread1.start();
        MyThread2 thread2 = new MyThread2(task);
        thread2.start();
    }
}
```

#### 2.2.5 synchronized代码块间的同步性

在使用synchronized(this)代码块时需要注意的是，当一个线程访问object的一个synchronized(this)同步代码块时，其它线程对同一个object中所有其他synchronized(this)同步代码块的访问被阻塞，这说明synchronized使用的**对象监视器**是一个。

```java
public class ObjectService {
    public void serviceMethodA(){
        try {
            synchronized (this){
                System.out.println("A begin time = " + System.currentTimeMillis());
                Thread.sleep(2000);
                System.out.println("A end end = " + System.currentTimeMillis());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void serviceMethodB(){
        synchronized (this){
            System.out.println("B begin time = " + System.currentTimeMillis());
            System.out.println("B end end = " + System.currentTimeMillis());
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private ObjectService service;

    public ThreadA(ObjectService service) {
        super();
        this.service = service;
    }

    @Override
    public void run() {
        super.run();
        service.serviceMethodA();
    }
}
```

```java
public class ThreadB extends Thread {
    private ObjectService service;

    public ThreadB(ObjectService service) {
        super();
        this.service = service;
    }

    @Override
    public void run() {
        super.run();
        service.serviceMethodB();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        ObjectService service = new ObjectService();
        ThreadA a = new ThreadA(service);
        a.setName("a");
        a.start();
        ThreadB b = new ThreadB(service);
        b.setName("b");
        b.start();
    }
}
```

输出：

```
A begin time = 1537601670607
A end end = 1537601672607
B begin time = 1537601672607
B end end = 1537601672607
```

#### 2.2.6 验证同步synchronized(this)代码块时锁定当前对象的

和synchronized方法一样，synchronized(this)代码块也是锁定当前对象的。

```java
public class Task {
    public void otherMethod() {
        System.out.println("-------------run--otherMethod");
    }
    public void doLongTimeTask(){
        synchronized (this){
            for (int i = 0; i < 10000; i++) {
                System.out.println("synchronized threadName = " + Thread.currentThread().getName() + " i = " + (i + 1));
            }
        }
    }
}
```

```java
public class MyThread1 extends Thread {
    private Task task;

    public MyThread1(Task task) {
        super();
        this.task = task;
    }

    @Override
    public void run() {
        super.run();
        task.doLongTimeTask();
    }
}
```

```java
public class MyThread2 extends Thread {
    private Task task;

    public MyThread2(Task task) {
        super();
        this.task = task;
    }

    @Override
    public void run() {
        super.run();
        task.otherMethod();
    }
}
```

输出：

```
...
synchronized threadName = Thread-0 i = 383
synchronized threadName = Thread-0 i = 384
-------------run--otherMethod
synchronized threadName = Thread-0 i = 385
synchronized threadName = Thread-0 i = 386
...
```

异步打印。

更改Task，将otherMethod更改为synchronized方法。

```
...
synchronized threadName = Thread-0 i = 9999
synchronized threadName = Thread-0 i = 10000
-------------run--otherMethod
```

同步打印。

#### 2.2.7 将任意对象作为对象监视器

多个线程调用同一对象中的不同名称的synchronized同步方法或synchronized(this)同步代码块时，调用的效果就是按顺序执行，也就是同步的，阻塞的。

synchronized同步方法或synchronized(this)同步代码块分别有两种作用：

##### 1. synchronized同步方法

1. 对其他synchronized同步方法或synchronized(this)同步代码块调用呈阻塞状态。
2. 同一时间只有一个线程可以执行synchronized同步方法中的代码。

##### 2. synchronized(this)同步代码块

1. 对其他synchronized同步方法或synchronized(this)同步代码块调用呈阻塞状态。
2. 同一时间只有一个线程可以执行synchronized(this)同步代码块中的代码。

Java支持对任意对象作为对象监视器来实现同步的功能。这个对象大多数是实例变量及方法的参数，使用方式为synchronized(非this对象)。

1. 在线程中持有对象监视器为同一个对象的前提下，同一时间只有一个线程可以执行synchronized(非this对象x)同步代码块中的代码。
2. 当持有对象监视器为统一对象的前提下，同一时间只有一个线程就可以执行synchronized(非this对象x)同步代码块中的代码。

```java
public class Service {
    private String usernameParam;
    private String passwordParam;
    private String anyString = new String();

    public void setUsernamePassword(String username, String password) {
        try {
            synchronized (anyString){
                System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 进入同步块");
                usernameParam = username;
                Thread.sleep(3000);
                passwordParam = password;
                System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 离开同步块");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private Service service;

    public ThreadA(Service service) {
        this.service = service;
    }

    @Override
    public void run() {
        service.setUsernamePassword("a", "aa");
    }
}
```

```java
public class ThreadB extends Thread {
    private Service service;

    public ThreadB(Service service) {
        this.service = service;
    }

    @Override
    public void run() {
        service.setUsernamePassword("b", "bb");
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        Service service = new Service();
        ThreadA a = new ThreadA(service);
        a.setName("A");
        a.start();
        ThreadB b = new ThreadB(service);
        b.setName("B");
        b.start();
    }
}
```

输出：

```
线程名称为：A 在 1537616710481 进入同步块
线程名称为：A 在 1537616713481 离开同步块
线程名称为：B 在 1537616713481 进入同步块
线程名称为：B 在 1537616716482 离开同步块
```

锁非this对象具有一定的优点：如果在一个类中很多个synchronized方法，这是虽然能实现同步，但会受到阻塞，所以影响运行效率；但如果使用同步代码块非this对象，则synchronized(非this)代码块中的程序与同步方法是异步的，不于其他锁this同步方法争抢this锁，则可大大提高效率。

更改Service，

```java
public class Service {
    private String usernameParam;
    private String passwordParam;
//    private String anyString = new String();

    public void setUsernamePassword(String username, String password) {
        try {
            String anyString = new String();
            synchronized (anyString){
                System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 进入同步块");
                usernameParam = username;
                Thread.sleep(3000);
                passwordParam = password;
                System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 离开同步块");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

输出：

```
线程名称为：A 在 1537617335577 进入同步块
线程名称为：B 在 1537617335577 进入同步块
线程名称为：B 在 1537617338578 离开同步块
线程名称为：A 在 1537617338578 离开同步块
```

使用synchronized(非this)同步代码块格式进行同步操作时，对象监视器必须是同一个对象、如果不是同一个对象监视器，运行的结果就是一部调用了，就会交叉运行。

```java
public class Service {
    private String anyString = new String();

    public void a() {
        try {
            synchronized (anyString) {
                System.out.println("a begin");
                Thread.sleep(3000);
                System.out.println("a end");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public synchronized void b() {
        System.out.println("b begin");
        System.out.println("b end");
    }
}
```

```java
public class ThreadA extends Thread {
    private Service service;

    public ThreadA(Service service) {
        this.service = service;
    }

    @Override
    public void run() {
        service.a();
    }
}
```

```java
public class ThreadB extends Thread {
    private Service service;

    public ThreadB(Service service) {
        this.service = service;
    }

    @Override
    public void run() {
        service.b();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        Service service = new Service();
        ThreadA a = new ThreadA(service);
        a.setName("A");
        a.start();
        ThreadB b = new ThreadB(service);
        b.setName("B");
        b.start();
    }
}
```

输出：

```
a begin
b begin
b end
a end
```

由于对象的监视器不同，所以运行结果是异步的。

同步代码块放在非同步synchronized方法中进行声明，并不能保证调用方法的线程的执行同步/顺序性，也就是说线程调用方法的顺序是无序的，虽然在同步块中执行的顺序是同步的，这样极易出现脏读问题。

使用synchronized(非this对象x)同步块格式可以解决脏读问题。但在解决脏读之前，需验证多个线程调用同一个方法是随机的。

```java
public class MyList {
    private List list = new ArrayList();
    public synchronized void add(String username){
        System.out.println("ThreadName = " + Thread.currentThread().getName() + " 执行了add方法！");
        list.add(username);
        System.out.println("ThreadName = " + Thread.currentThread().getName() + " 退出了add方法！");
    }
    public synchronized int getSize(){
        System.out.println("ThreadName = " + Thread.currentThread().getName() + " 执行了getSize方法！");
        int sizeValue = list.size();
        System.out.println("ThreadName = " + Thread.currentThread().getName() + " 退出了getSize方法！");
        return sizeValue;
    }
}
```

```java
public class MyThreadA extends Thread {
    private MyList list;

    public MyThreadA(MyList list) {
        this.list = list;
    }

    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            list.add("ThreadA " + (i + 1));
        }
    }
}
```

```java
public class MyThreadB extends Thread {
    private MyList list;

    public MyThreadB(MyList list) {
        this.list = list;
    }

    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            list.add("ThreadB " + (i + 1));
        }
    }
}
```

```java
public class Test {
    public static void main(String[] args) {
        MyList myList = new MyList();
        MyThreadA a = new MyThreadA(myList);
        a.setName("A");
        a.start();
        MyThreadB b = new MyThreadB(myList);
        b.setName("B");
        b.start();
    }
}
```

输出：

```
ThreadName = A 执行了add方法！
ThreadName = A 退出了add方法！
ThreadName = B 执行了add方法！
ThreadName = B 退出了add方法！
ThreadName = A 执行了add方法！
ThreadName = A 退出了add方法！
...
```

同步块中的代码是同步打印的，当前线程的执行和退出是同步出现的。但线程A和线程B的执行却是异步的，这就有可能出现脏读的环境。

```java
public class MyOneList {
    private List list = new ArrayList();
    public synchronized void add(String data){
        list.add(data);
    }
    public synchronized int getSize(){
        return list.size();
    }
}
```

```java
public class MyService {
    public MyOneList addServiceMethod(MyOneList list, String  data){
        try {
            if (list.getSize() < 1){
                Thread.sleep(2000);
                list.add(data);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return list;
    }
}
```

```java
public class MyThread1 extends Thread {
    private MyOneList list;

    public MyThread1(MyOneList list) {
        super();
        this.list = list;
    }

    @Override
    public void run() {
        MyService msRef = new MyService();
        msRef.addServiceMethod(list, "A");
    }
}
```

```java
public class MyThread2 extends Thread {
    private MyOneList list;

    public MyThread2(MyOneList list) {
        super();
        this.list = list;
    }

    @Override
    public void run() {
        MyService msRef = new MyService();
        msRef.addServiceMethod(list, "B");
    }
}
```

```java
public class Run {
    public static void main(String[] args) throws InterruptedException {
        MyOneList list = new MyOneList();
        MyThread1 thread1 = new MyThread1(list);
        thread1.setName("A");
        thread1.start();
        MyThread2 thread2 = new MyThread2(list);
        thread1.setName("B");
        thread2.start();
        Thread.sleep(6000);
        System.out.println("listSize = " + list.getSize());
    }
}
```

输出：

```
listSize = 2
```

脏读出现了，出现的原因是两个线程以异步的方式返回list参数的size大小，办法就是同步化。

更改Service文件，

```java
public class MyService {
    public MyOneList addServiceMethod(MyOneList list, String  data){
        try {
            synchronized (list){
                if (list.getSize() < 1){
                    Thread.sleep(2000);
                    list.add(data);
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return list;
    }
}
```

由于list参数对象在项目中是一份实例，是单例的，而且也真正需要对参数的getSize()方法做同步的调用，所以对list参数的同步处理。

输出：

```
listSize = 1
```

#### 2.2.8 细化验证3个结论

synchronized(非this对象x)格式的写法是将x对象本身作为对象监视器，这样就可以得出3个结论：

1. 当多个线程同时执行synchronized(x){}同步代码块时呈同步效果。
2. 当其他线程执行x对象中synchronized同步方法时呈同步效果。
3. 当其他线程执行x对象方法里面的synchronized(this)代码块也呈现同步效果。

注意：如果其他线程调用不加synchronized关键字的方法时，还是异步调用。

##### 1.验证第1个结论

当多个线程同时执行synchronized(x){}同步代码块时呈同步效果。

```java
public class MyObject {
}
```

```java
public class Service {
    public void testMethod1(MyObject object){
        synchronized (object){
            try {
                System.out.println("testMethod1 __getLock time = " +  System.currentTimeMillis() + " run ThreadName = " + Thread.currentThread().getName());
                Thread.sleep(2000);
                System.out.println("testMethod1 releaseLock time = " +  System.currentTimeMillis() + " run ThreadName = " + Thread.currentThread().getName());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private Service service;
    private MyObject object;

    public ThreadA(Service service, MyObject object) {
        this.service = service;
        this.object = object;
    }

    @Override
    public void run() {
        super.run();
        service.testMethod1(object);
    }
}
```

```java
public class ThreadB extends Thread {
    private Service service;
    private MyObject object;

    public ThreadB(Service service, MyObject object) {
        this.service = service;
        this.object = object;
    }

    @Override
    public void run() {
        super.run();
        service.testMethod1(object);
    }
}
```

```java
public class Run_1 {
    public static void main(String[] args) {
        Service service = new Service();
        MyObject object = new MyObject();
        ThreadA a = new ThreadA(service, object);
        a.setName("a");
        a.start();
        ThreadB b = new ThreadB(service, object);
        b.setName("b");
        b.start();
    }
}
```

输出：

```
testMethod1 __getLock time = 1537703553775 run ThreadName = a
testMethod1 releaseLock time = 1537703555776 run ThreadName = a
testMethod1 __getLock time = 1537703555776 run ThreadName = b
testMethod1 releaseLock time = 1537703557776 run ThreadName = b
```

同步的原因是使用了同一个对象监视器。

使用不同的对象监视器：

```java
public class Run_2 {
    public static void main(String[] args) {
        Service service = new Service();
        MyObject object1 = new MyObject();
        MyObject object2 = new MyObject();
        ThreadA a = new ThreadA(service, object1);
        a.setName("a");
        a.start();
        ThreadB b = new ThreadB(service, object2);
        b.setName("b");
        b.start();
    }
}
```

输出：

```
testMethod1 __getLock time = 1537703855944 run ThreadName = a
testMethod1 __getLock time = 1537703855948 run ThreadName = b
testMethod1 releaseLock time = 1537703857949 run ThreadName = b
testMethod1 releaseLock time = 1537703857950 run ThreadName = a
```

##### 2.验证第二个结论

当其他线程执行x对象中synchronized同步方法时呈同步效果。

```java
public class MyObject {
    public synchronized void speedPrintString(){
        System.out.println("speedPrintString __getLock time = " +  System.currentTimeMillis() + " run ThreadName = " + Thread.currentThread().getName());
        System.out.println("---------------");
        System.out.println("speedPrintString releaseLock time = " +  System.currentTimeMillis() + " run ThreadName = " + Thread.currentThread().getName());
    }
}
```

```java
public class Service {
    public void testMethod1(MyObject object){
        synchronized (object){
            try {
                System.out.println("testMethod1 __getLock time = " +  System.currentTimeMillis() + " run ThreadName = " + Thread.currentThread().getName());
                Thread.sleep(5000);
                System.out.println("testMethod1 releaseLock time = " +  System.currentTimeMillis() + " run ThreadName = " + Thread.currentThread().getName());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private Service service;
    private MyObject object;

    public ThreadA(Service service, MyObject object) {
        this.service = service;
        this.object = object;
    }

    @Override
    public void run() {
        super.run();
        service.testMethod1(object);
    }
}
```

```java
public class ThreadB extends Thread {
    private MyObject object;

    public ThreadB(MyObject object) {
        this.object = object;
    }

    @Override
    public void run() {
        super.run();
        object.speedPrintString();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        Service service = new Service();
        MyObject object = new MyObject();
        ThreadA a = new ThreadA(service, object);
        a.setName("a");
        a.start();
        ThreadB b = new ThreadB(object);
        b.setName("b");
        b.start();
    }
}
```

输出：

```
testMethod1 __getLock time = 1537704426489 run ThreadName = a
testMethod1 releaseLock time = 1537704431490 run ThreadName = a
speedPrintString __getLock time = 1537704431490 run ThreadName = b
---------------
speedPrintString releaseLock time = 1537704431492 run ThreadName = b
```

##### 3.验证第三个结论

当其他线程执行x对象方法里面的synchronized(this)代码块也呈现同步效果。

只改MyObject，

```java
public class MyObject {
    public void speedPrintString() {
        synchronized (this) {
            System.out.println("speedPrintString __getLock time = " + System.currentTimeMillis() + " run ThreadName = " + Thread.currentThread().getName());
            System.out.println("---------------");
            System.out.println("speedPrintString releaseLock time = " + System.currentTimeMillis() + " run ThreadName = " + Thread.currentThread().getName());
        }
    }
}
```

输出：

```
testMethod1 __getLock time = 1537705336821 run ThreadName = a
testMethod1 releaseLock time = 1537705341823 run ThreadName = a
speedPrintString __getLock time = 1537705341823 run ThreadName = b
---------------
speedPrintString releaseLock time = 1537705341823 run ThreadName = b
```

#### 2.2.9 静态同步synchronized方法与synchronized(class)代码块

关键字synchronized还可以应用在static方法上，如果这样写，那是对当前*.java文件对应的Class类进行持锁，

```java
public class Service {
    public synchronized static void printA() {
        try {
            System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 进入printA");
            Thread.sleep(3000);
            System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 离开printA");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public synchronized static void printB() {
        System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 进入printB");
        System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 离开printB");
    }
}
```

```java
public class ThreadA extends Thread {
    @Override
    public void run() {
        Service.printA();
    }
}
```

```java
public class ThreadB extends Thread {
    @Override
    public void run() {
        Service.printB();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        ThreadA a = new ThreadA();
        a.setName("A");
        a.start();
        ThreadB b = new ThreadB();
        b.setName("B");
        b.start();
    }
}
```

输出：

```
线程名称为：A 在 1537705806741 进入printA
线程名称为：A 在 1537705809742 离开printA
线程名称为：B 在 1537705809742 进入printB
线程名称为：B 在 1537705809742 离开printB
```

结果都是同步的效果，和将synchronized关键字加到非static方法上使用的效果是一样的。其实还是有本质上的不同的，synchronized关键字加到static静态方法上是给Class类上锁，而synchronized关键字加到非static静态方法上是给对象上锁。

验证不是同一个锁，

```java
public class Service {
    public synchronized static void printA() {
        try {
            System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 进入printA");
            Thread.sleep(3000);
            System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 离开printA");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public synchronized static void printB() {
        System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 进入printB");
        System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 离开printB");
    }

    public synchronized void printC() {
        System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 进入printC");
        System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 离开printC");
    }
}
```

```java
public class ThreadA extends Thread {
    private Service service;

    public ThreadA(Service service) {
        this.service = service;
    }

    @Override
    public void run() {
        service.printA();
    }
}
```

```java
public class ThreadB extends Thread {
    private Service service;

    public ThreadB(Service service) {
        this.service = service;
    }

    @Override
    public void run() {
        service.printB();
    }
}
```

```java
public class ThreadC extends Thread {
    private Service service;

    public ThreadC(Service service) {
        this.service = service;
    }

    @Override
    public void run() {
        service.printC();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        Service service = new Service();
        ThreadA a = new ThreadA(service);
        a.setName("A");
        a.start();
        ThreadB b  = new ThreadB(service);
        b.setName("B");
        b.start();
        ThreadC c = new ThreadC(service);
        c.setName("C");
        c.start();
    }
}
```

输出：

```
线程名称为：A 在 1537706476308 进入printA
线程名称为：C 在 1537706476310 进入printC
线程名称为：C 在 1537706476310 离开printC
线程名称为：A 在 1537706479308 离开printA
线程名称为：B 在 1537706479308 进入printB
线程名称为：B 在 1537706479308 离开printB
```

异步的原因是持有不同的锁，一个是对象锁，另外一个是Class锁，而Class锁可以对类的所有对象实例起作用。

```java
public class Service {
    public synchronized static void printA() {
        try {
            System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 进入printA");
            Thread.sleep(3000);
            System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 离开printA");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public synchronized static void printB() {
        System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 进入printB");
        System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 离开printB");
    }
}
```

```java
public class ThreadA extends Thread {
    private Service service;

    public ThreadA(Service service) {
        this.service = service;
    }

    @Override
    public void run() {
        service.printA();
    }
}
```

```java
public class ThreadB extends Thread {
    private Service service;

    public ThreadB(Service service) {
        this.service = service;
    }

    @Override
    public void run() {
        service.printB();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        Service service1 = new Service();
        Service service2 = new Service();
        ThreadA a = new ThreadA(service1);
        a.setName("A");
        a.start();
        ThreadB b  = new ThreadB(service2);
        b.setName("B");
        b.start();
    }
}
```

输出：

```
线程名称为：A 在 1537707057246 进入printA
线程名称为：A 在 1537707060247 离开printA
线程名称为：B 在 1537707060247 进入printB
线程名称为：B 在 1537707060247 离开printB
```

同步synchronized(this)代码块的作用其实和synchronized static方法的作用一样。

```java
public class Service {
    public static void printA() {
        synchronized (Service.class) {
            try {
                System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 进入printA");
                Thread.sleep(3000);
                System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 离开printA");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void printB() {
        synchronized (Service.class) {
            System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 进入printB");
            System.out.println("线程名称为：" + Thread.currentThread().getName() + " 在 " + System.currentTimeMillis() + " 离开printB");
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private Service service;

    public ThreadA(Service service) {
        this.service = service;
    }

    @Override
    public void run() {
        service.printA();
    }
}
```

```java
public class ThreadB extends Thread {
    private Service service;

    public ThreadB(Service service) {
        this.service = service;
    }

    @Override
    public void run() {
        service.printB();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        Service service1 = new Service();
        Service service2 = new Service();
        ThreadA a = new ThreadA(service1);
        a.setName("A");
        a.start();
        ThreadB b  = new ThreadB(service2);
        b.setName("B");
        b.start();
    }
}
```

输出：

```
线程名称为：A 在 1537707388148 进入printA
线程名称为：A 在 1537707391148 离开printA
线程名称为：B 在 1537707391148 进入printB
线程名称为：B 在 1537707391148 离开printB
```

#### 2.2.10 数据类型String的常量池特性

在JVM中具有String常量池缓存的功能，

```java
public class Test {
    public static void main(String[] args) {
        String a = "a";
        String b = "a";
        System.out.println(a == b);
    }
}
```

结果为true。

将synchronized(string)同步块与String联合使用是时，要注意常量池带来的一些例外。

```java
public class Service {
    public static void print(String stringParam) {
        try {
            synchronized (stringParam) {
                while (true) {
                    System.out.println(Thread.currentThread().getName());
                    Thread.sleep(1000);
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private Service service;

    public ThreadA(Service service) {
        this.service = service;
    }

    @Override
    public void run() {
        super.run();
        service.print("AA");
    }
}
```

```java
public class ThreadB extends Thread {
    private Service service;

    public ThreadB(Service service) {
        this.service = service;
    }

    @Override
    public void run() {
        super.run();
        service.print("AA");
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        Service service = new Service();
        ThreadA a = new ThreadA(service);
        a.setName("A");
        a.start();
        ThreadB b = new ThreadB(service);
        b.setName("B");
        b.start();
    }
}
```

输出：

```
A
A
...
```

出现这样的情况就是因为String的两个值都是AA，两个线程持有相同的锁，所以造成线程B不能执行。这就是String常量池所带来的问题。因此在大多数情况下，同步synchronized代码块都不使用String作为锁对象，而改用其他，比如`new Object()`实例化一个Object对象，但它并不放入缓存中。

```java
public class Service {
    public static void print(Object object) {
        try {
            synchronized (object) {
                while (true) {
                    System.out.println(Thread.currentThread().getName());
                    Thread.sleep(1000);
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private Service service;

    public ThreadA(Service service) {
        this.service = service;
    }

    @Override
    public void run() {
        super.run();
        service.print(new Object());
    }
}
```

```java
public class ThreadB extends Thread {
    private Service service;

    public ThreadB(Service service) {
        this.service = service;
    }

    @Override
    public void run() {
        super.run();
        service.print(new Object());
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        Service service = new Service();
        ThreadA a = new ThreadA(service);
        a.setName("A");
        a.start();
        ThreadB b = new ThreadB(service);
        b.setName("B");
        b.start();
    }
}
```

输出：

```
A
B
A
A
B
...
```

交替打印的原因是持有的锁不是同一个。

#### 2.2.11 同步synchronized方法无限等待与解决

同步方法容易造成死循环。

```java
public class Service {
    public synchronized void methodA() {
        System.out.println("methodA begin");
        boolean isContinueRun = true;
        while (isContinueRun){
        }
        System.out.println("method end");
    }

    public synchronized void methodB() {
        System.out.println("methodB begin");
        System.out.println("methodB end");
    }
}
```

```java
public class ThreadA extends Thread {
    private Service service;

    public ThreadA(Service service) {
        this.service = service;
    }

    @Override
    public void run() {
        super.run();
        service.methodA();
    }
}
```

```java
public class ThreadB extends Thread {
    private Service service;

    public ThreadB(Service service) {
        this.service = service;
    }

    @Override
    public void run() {
        super.run();
        service.methodB();
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        Service service = new Service();
        ThreadA athread = new ThreadA(service);
        athread.start();
        ThreadB bthread = new ThreadB(service);
        bthread.start();
    }
}
```

输出：

```
methodA begin

```

线程B永远得不到运行的机会，锁死了。

这时就可以使用同步块来解决这样的问题。

更改Service文件，

```java
public class Service {

    Object object1 = new Object();
    public void methodA() {
        synchronized (object1) {
            System.out.println("methodA begin");
            boolean isContinueRun = true;
            while (isContinueRun) {
            }
            System.out.println("method end");
        }
    }

    Object object2 = new Object();
    public void methodB() {
        synchronized (object1) {
            System.out.println("methodB begin");
            System.out.println("methodB end");
        }
    }
}
```

输出：

```
methodA begin
methodB begin
methodB end
```

#### 2.2.12 多线程的死锁

Java线程死锁是一个经典的多线程问题，因为不同的线程都在等待根本不可能释放的锁，从而导致所有的任务都无法继续完成。在多线程技术中，死锁是必须避免的，因为这会造成线程的假死。

```java
public class DealThread extends Thread {
    public String username;
    public Object lock1 = new Object();
    public Object lock2 = new Object();

    public void setFlag(String username) {
        this.username = username;
    }

    @Override
    public void run() {
        if (username.equals("a")) {
            synchronized (lock1) {
                try {
                    System.out.println("username = " + username);
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lock2) {
                    System.out.println("按lock1->lock2代码顺序执行了");
                }
            }
        }
        if (username.equals("b")) {
            synchronized (lock2) {
                try {
                    System.out.println("username = " + username);
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lock1) {
                    System.out.println("按lock2->lock1代码顺序执行了");
                }
            }
        }
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        try {
            DealThread t1 = new DealThread();
            t1.setFlag("a");
            Thread thread1 = new Thread(t1);
            thread1.start();
            Thread.sleep(100);
            t1.setFlag("b");
            Thread thread2 = new Thread(t1);
            thread2.start();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

输出：

```
username = a
username = b
```

![死锁1](E:\Github仓库\Notes\Java\Java多线程编程核心技术\assets\死锁1.png)

![死锁2](E:\Github仓库\Notes\Java\Java多线程编程核心技术\assets\死锁2.png)

![死锁3](E:\Github仓库\Notes\Java\Java多线程编程核心技术\assets\死锁3.png)

#### 2.2.13 内置类和静态内置类

```java
public class PublicClass {
    private String username;
    private String password;

    class PrivateClass {
        private String age;
        private String address;

        public String getAge() {
            return age;
        }

        public void setAge(String age) {
            this.age = age;
        }

        public String getAddress() {
            return address;
        }

        public void setAddress(String address) {
            this.address = address;
        }
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        PublicClass publicClass = new PublicClass();
        publicClass.setUsername("usernameValue");
        publicClass.setPassword("passwordValue");
        System.out.println(publicClass.getUsername() + " " + publicClass.getPassword());
        PublicClass.PrivateClass privateClass = publicClass.new PrivateClass();
        privateClass.setAge("ageValue");
        privateClass.setAddress("addressValue");
        System.out.println(privateClass.getAge() + " " + privateClass.getAddress());
    }
}
```

输出：

```
usernameValue passwordValue
ageValue addressValue
```

如果PublicClass.java类和Run.java类不在同一个包，则需要将PrivateClass内置声明为public公开的。

内置类还有一种叫做静态内置类。

```java
public class PublicClass {
    private String username;
    private String password;

    static class PrivateClass {
        private String age;
        private String address;

        public String getAge() {
            return age;
        }

        public void setAge(String age) {
            this.age = age;
        }

        public String getAddress() {
            return address;
        }

        public void setAddress(String address) {
            this.address = address;
        }
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        PublicClass publicClass = new PublicClass();
        publicClass.setUsername("usernameValue");
        publicClass.setPassword("passwordValue");
        System.out.println(publicClass.getUsername() + " " + publicClass.getPassword());
        PublicClass.PrivateClass privateClass = new PublicClass.PrivateClass();
        privateClass.setAge("ageValue");
        privateClass.setAddress("addressValue");
        System.out.println(privateClass.getAge() + " " + privateClass.getAddress());
    }
}
```

输出：

```
usernameValue passwordValue
ageValue addressValue
```

#### 2.2.14 内置类与同步：实验1

本实验使用的案例是在内置类中有两个同步方法，但使用的却是不同的锁，打印的结果也异步的。

```java
public class OutClass {
    static class Inner {
        public void method1() {
            synchronized ("其他的锁") {
                for (int i = 0; i < 10; i++) {
                    System.out.println(Thread.currentThread().getName() + "i = " + i);
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }

        public synchronized void method2() {
            for (int i = 0; i < 20; i++) {
                System.out.println(Thread.currentThread().getName() + "i = " + i);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        final OutClass.Inner inner = new OutClass.Inner();
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                inner.method1();
            }
        }, "A");
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                inner.method2();
            }
        }, "B");
        t1.start();
        t2.start();
    }
}
```

输出：

```
Ai = 0
Bi = 0
Bi = 1
Ai = 1
Bi = 2
Ai = 2
Ai = 3
Bi = 3
Bi = 4
Ai = 4
Bi = 5
Ai = 5
Ai = 6
Bi = 6
Ai = 7
Bi = 7
Bi = 8
Ai = 8
Ai = 9
Bi = 9
Bi = 10
Bi = 11
Bi = 12
Bi = 13
Bi = 14
Bi = 15
Bi = 16
Bi = 17
Bi = 18
Bi = 19
```

由于持有不同的对象监视器，所以打印结果是无序的。

#### 2.2.15 内置类与同步：实验2

本实验测试同步代码块synchronized(class2)对class2上锁后，其他线程只能以同步的方式调用class2中的静态同步方法。

```java
public class OutClass {
    static class InnerClass1 {
        public void method1(InnerClass2 class2) {
            String threadName = Thread.currentThread().getName();
            synchronized (class2) {
                System.out.println(threadName + "进入InnerClass1类中的method1方法");
                for (int i = 0; i < 10; i++) {
                    System.out.println("i = " + i);
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(threadName + "离开InnerClass1类中的method1方法");
            }
        }

        public synchronized void method2() {
            String threadName = Thread.currentThread().getName();
            System.out.println(threadName  + "进入InnerClass1类中的method2方法");
            for (int j = 0; j < 10; j++) {
                System.out.println("j = " + j);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(threadName + "离开InnerClass1类中的method2方法");
        }
    }
    static class InnerClass2 {
        public synchronized void method1() {
            String threadName = Thread.currentThread().getName();
            System.out.println(threadName  + "进入InnerClass2类中的method1方法");
            synchronized ("其他的锁") {
                for (int k = 0; k < 10; k++) {
                    System.out.println("k = " + k);
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(threadName + "离开InnerClass2类中的method1方法");
            }
        }
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        final OutClass.InnerClass1 in1 = new OutClass.InnerClass1();
        final OutClass.InnerClass2 in2 = new OutClass.InnerClass2();
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                in1.method1(in2);
            }
        }, "T1");
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                in1.method2();
            }
        }, "T2");
        Thread t3 = new Thread(new Runnable() {
            @Override
            public void run() {
                in2.method1();
            }
        }, "T3");
        t1.start();
        t2.start();
        t3.start();
    }
}
```

输出：

```
T1进入InnerClass1类中的method1方法
i = 0
T2进入InnerClass1类中的method2方法
j = 0
j = 1
i = 1
i = 2
j = 2
j = 3
i = 3
i = 4
j = 4
i = 5
j = 5
j = 6
i = 6
j = 7
i = 7
j = 8
i = 8
i = 9
j = 9
T1离开InnerClass1类中的method1方法
T3进入InnerClass2类中的method1方法
k = 0
T2离开InnerClass1类中的method2方法
k = 1
k = 2
k = 3
k = 4
k = 5
k = 6
k = 7
k = 8
k = 9
T3离开InnerClass2类中的method1方法
```

#### 2.2.16 锁对象的改变

在将任何数据类型作为同步锁时，需要注意的是，是否有多个线程同时持有锁对象，这些线程之间是异步的。

```java
public class MyService {
    private String lock = "123";

    public void testMethod() {
        try {
            synchronized (lock){
                System.out.println(Thread.currentThread().getName() + " begin " + System.currentTimeMillis());
                lock = "456";
                Thread.sleep(2000);
                System.out.println(Thread.currentThread().getName() + " end " + System.currentTimeMillis());
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private MyService service;

    public ThreadA(MyService service) {
        super();
        this.service = service;
    }

    @Override
    public void run() {
        service.testMethod();
    }
}
```

```java
public class ThreadB extends Thread {
    private MyService service;

    public ThreadB(MyService service) {
        super();
        this.service = service;
    }

    @Override
    public void run() {
        service.testMethod();
    }
}
```

```java
public class Run1 {
    public static void main(String[] args) throws InterruptedException {
        MyService service = new MyService();
        ThreadA a = new ThreadA(service);
        a.setName("A");
        ThreadB b = new ThreadB(service);
        b.setName("B");
        a.start();
        Thread.sleep(50);
        b.start();
    }
}
```

输出：

```
A begin 1538660899929
B begin 1538660899979
A end 1538660901931
B end 1538660901980
```

50毫秒后取得的锁是“456”。

```java
public class Run2 {
    public static void main(String[] args) throws InterruptedException {
        MyService service = new MyService();
        ThreadA a = new ThreadA(service);
        a.setName("A");
        ThreadB b = new ThreadB(service);
        b.setName("B");
        a.start();
        b.start();
    }
}
```

输出：

```
A begin 1538703996667
A end 1538703998672
B begin 1538703998673
B end 1538704000674
```

线程A和B持有的锁是“123”，虽然将锁改成了“456”，但是还是同步的，因为A和B共同争抢的锁是“123”。

只要对象不变，即使对象的属性被改变，运行的结果还是同步的。

```java
public class UserInfo {
    private String username;
    private String password;

    public UserInfo() {
    }

    public UserInfo(String username, String password) {
        this.username = username;
        this.password = password;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```

```java
public class Service {
    public void serviceMethodA(UserInfo userInfo) {
        synchronized (userInfo) {
            try {
                System.out.println(Thread.currentThread().getName());
                userInfo.setUsername("abcabcabc");
                Thread.sleep(3000);
                System.out.println("end! time = " + System.currentTimeMillis());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
public class ThreadA extends Thread {
    private Service service;
    private UserInfo userInfo;

    public ThreadA(Service service, UserInfo userInfo) {
        this.service = service;
        this.userInfo = userInfo;
    }

    @Override
    public void run() {
        service.serviceMethodA(userInfo);
    }
}
```

```java
public class ThreadB extends Thread {
    private Service service;
    private UserInfo userInfo;

    public ThreadB(Service service, UserInfo userInfo) {
        this.service = service;
        this.userInfo = userInfo;
    }

    @Override
    public void run() {
        service.serviceMethodA(userInfo);
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        try {
            Service service = new Service();
            UserInfo userInfo = new UserInfo();
            ThreadA a = new ThreadA(service, userInfo);
            a.setName("a");
            a.start();
            Thread.sleep(50);
            ThreadB b = new ThreadB(service,userInfo);
            b.setName("b");
            b.start();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

输出：

```
a
end! time = 1538704731239
b
end! time = 1538704734240
```