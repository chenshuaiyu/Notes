# 1.Java多线程技能

### 1.1 进程和多线程的概念及线程的优点

进程是受操作系统控制的基本单元。

线程是进程中独立运行的子任务。

### 1.2 使用多线程

#### 1.2.1 继承Thread类

```java
public class Thread implements Runnable
```

```java
public class MyThread extends Thread {

    @Override
    public void run() {
        super.run();
        System.out.println("MyThread");
    }
}
```

```java
public class MyThread extends Thread {

    @Override
    public void run() {
        super.run();
        System.out.println("MyThread");
    }
}
```

输出：

运行结束！
MyThread

使用多线程技术时，代码的执行结果与代码的执行顺序或调用顺序是无关的。

```java
public class MyThread extends Thread {

    @Override
    public void run() {
        super.run();
        try {
            for (int i = 0; i < 10; i++) {
                int time = (int) (Math.random() * 1000);
                Thread.sleep(time);
                System.out.println("run = " + Thread.currentThread().getName());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class Test {

    public static void main(String[] args) {
        try{
            MyThread thread = new MyThread();
            thread.setName("myThread");
            thread.start();

            for (int i = 0; i < 10; i++) {
                int time = (int) (Math.random() * 1000);
                Thread.sleep(time);
                System.out.println("run = " +Thread.currentThread().getName());
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

输出是不确定的。

**注意：**

1. 如果调用`thread.run()`，那么就是同步执行。
2. start执行的顺序不代表线程启动的顺序。

#### 1.2.2 实现Runnable接口

```java
public class MyRunnable implements Runnable  {

    @Override
    public void run() {
        System.out.println("运行中！");
    }
}
```

```java
public class Run {

    public static void main(String[] args) {
        Runnable runnable = new MyRunnable();
        Thread thread = new Thread(runnable);
        thread.start();
        System.out.println("运行结束！");
    }
}
```

输出：

运行结束！
运行中！

Thread类也实现了Runnable接口，意味着也可以传入一个Thread对象，这样做完全可以将一个Thread对象的run()方法交给其他的线程调用。

#### 1.2.3 实例变量与线程安全

```java
public class MyThread extends Thread {
    private int count = 5;

    public MyThread(String name) {
        super();
        this.setName(name);//设置线程名称
    }

    @Override
    public void run() {
        super.run();
        while (count > 0) {
            count--;
            System.out.println("由 " + this.currentThread().getName() + " 计算，count = " + count);
        }
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        MyThread a = new MyThread("A");
        MyThread b = new MyThread("B");
        MyThread c = new MyThread("C");
        a.start();
        b.start();
        c.start();
    }
}
```

共享数据的情况就是多个线程可以访问同一个变量。

```java
public class MyThread extends Thread {
    private int count = 5;

    @Override
    public void run() {
        super.run();
        count--;
        System.out.println("由 " + this.currentThread().getName() + " 计算，count = " + count);
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        Thread a = new Thread(myThread,"A");
        Thread b = new Thread(myThread,"B");
        Thread c = new Thread(myThread,"C");
        Thread d = new Thread(myThread,"D");
        Thread e = new Thread(myThread,"E");
        a.start();
        b.start();
        c.start();
        d.start();
        e.start();
    }
}
```

输出：

由 B 计算，count = 3
由 C 计算，count = 2
由 A 计算，count = 3
由 E 计算，count = 1
由 D 计算，count = 0

产生了非线程安全问题。

```java
public class MyThread extends Thread {
    private int count = 5;

	//添加synchronized关键字
    @Override
    public synchronized void run() {
        super.run();
        count--;
        System.out.println("由 " + this.currentThread().getName() + " 计算，count = " + count);
    }
}
```

synchronized可以在任意对象及方法上加锁，而加锁的这段代码称为互斥区或临界区。

实现一下非线程安全的环境：

```java
public class LoginServlet {
    private static String usernameRef;
    private static String passwordRef;

    public static void doPost(String useranme, String password) {
        try {
            usernameRef = useranme;
            if (useranme.equals("a")) {
                Thread.sleep(5000);
            }
            passwordRef = password;
            System.out.println("username = " + usernameRef + " password = " + password);

        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}
```

```java
public class ALogin extends Thread {
    @Override
    public void run() {
        super.run();
        LoginServlet.doPost("a", "aa");
    }
}

public class BLogin extends Thread {
    @Override
    public void run() {
        super.run();
        LoginServlet.doPost("b", "bb");
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        ALogin a = new ALogin();
        a.start();
        BLogin b = new BLogin();
        b.start();
    }
}
```

输出：

username = b password = bb
username = b password = aa

使用synchronized关键字解决：

```java
public static synchronized void doPost(String useranme, String password) {
    try {
        usernameRef = useranme;
        if (useranme.equals("a")) {
            Thread.sleep(5000);
        }
        passwordRef = password;
        System.out.println("username = " + usernameRef + " password = " + password);

    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

输出：

username = a password = aa
username = b password = bb

#### 1.2.4 留意 i-- 与System.out.println()的异常

```java
public class MyThread extends Thread {
    private int i = 5;
    @Override
    public void run() {
        super.run();
        System.out.println("i = " + i-- + " threadName = " + Thread.currentThread().getName());
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        MyThread run = new MyThread();
        Thread t1 = new Thread(run);
        Thread t2 = new Thread(run);
        Thread t3 = new Thread(run);
        Thread t4 = new Thread(run);
        Thread t5 = new Thread(run);
        t1.start();
        t2.start();
        t3.start();
        t4.start();
        t5.start();
    }
}
```

输出：

i = 5 threadName = Thread-2
i = 5 threadName = Thread-1
i = 4 threadName = Thread-3
i = 3 threadName = Thread-5
i = 2 threadName = Thread-4

虽然println()方法在内部是同步的，但i--的操作却是在进入println()之前发生的，所以有发生线程安全问题的概率。

所以，为了防止发生非线程安全问题，还是应继续使用同步方法。

### 1.3 currentThread()方法

返回代码段正在被哪个线程调用的信息。

```java
public class Run1 {
    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName());
    }
}
```

输出：

main

```java
public class MyThread extends Thread {
    public MyThread() {
        System.out.println("构造方法的打印：" + Thread.currentThread().getName());
    }

    @Override
    public void run() {
        super.run();
        System.out.println("run方法的打印：" + Thread.currentThread().getName());
    }
}
```

```java
public class Run2 {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
    }
}
```

输出：

构造方法的打印：main
run方法的打印：Thread-0

```java
public class Run2 {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.run();
    }
}
```

输出：

构造方法的打印：main
run方法的打印：main

```java
public class CountOperate extends Thread {
    public CountOperate() {
        System.out.println("CountOperate---begin");
        System.out.println("Thread.currentThread().getName() = " + Thread.currentThread().getName());
        System.out.println("this.getName() = " + this.getName());
        System.out.println("CountOperate---end");
    }

    @Override
    public void run() {
        super.run();
        System.out.println("run---begin");
        System.out.println("Thread.currentThread().getName() = " + Thread.currentThread().getName());
        System.out.println("this.getName() = " + this.getName());
        System.out.println("run---end");
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        CountOperate c = new CountOperate();
        Thread t1 = new Thread(c);
        t1.setName("A");
        t1.start();
    }
}
```

输出：

CountOperate---begin
Thread.currentThread().getName() = main
this.getName() = Thread-0
CountOperate---end
run---begin
Thread.currentThread().getName() = A
this.getName() = Thread-0
run---end

### 1.4 isAlive()方法

判断当前的线程是否处于活动状态。

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        super.run();
        System.out.println("run = "+ this.isAlive());
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        System.out.println("begin == " + myThread.isAlive());
        myThread.start();
        System.out.println("end == " + myThread.isAlive());
    }
}
```

输出：

begin == false
end == true
run = true

```java
public class Run {
    public static void main(String[] args) throws InterruptedException {
        MyThread myThread = new MyThread();
        System.out.println("begin == " + myThread.isAlive());
        myThread.start();
        Thread.sleep(1000) ;
        System.out.println("end == " + myThread.isAlive());
    }
}
```

输出：

begin == false
run = true
end == false

myThread对象已在1秒内执行完毕。

```java
public class CountOperate extends Thread {
    public CountOperate() {
        System.out.println("CountOperate---begin");
        System.out.println("Thread.currentThread().getName() = " + Thread.currentThread().getName());
        System.out.println("Thread.currentThread().isAlive() = " + Thread.currentThread().isAlive());
        System.out.println("this.getName() = " + this.getName());
        System.out.println("this.isAlive() = " + this.isAlive());
        System.out.println("CountOperate---end");
    }

    @Override
    public void run() {
        super.run();
        System.out.println("run---begin");
        System.out.println("Thread.currentThread().getName() = " + Thread.currentThread().getName());
        System.out.println("Thread.currentThread().isAlive() = " + Thread.currentThread().isAlive());
        System.out.println("this.getName() = " + this.getName());
        System.out.println("this.isAlive() = " + this.isAlive());
        System.out.println("run---end");
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        CountOperate c = new CountOperate();
        Thread t1 = new Thread(c);
        System.out.println("main begin t1 isAlive = " + t1.isAlive());
        t1.setName("A");
        t1.start();
        System.out.println("main end t1 isAlive = " + t1.isAlive());
    }
}
```

输出：

CountOperate---begin
Thread.currentThread().getName() = main
Thread.currentThread().isAlive() = true
this.getName() = Thread-0
this.isAlive() = false
CountOperate---end
main begin t1 isAlive = false
main end t1 isAlive = true
run---begin
Thread.currentThread().getName() = A
Thread.currentThread().isAlive() = true
this.getName() = Thread-0
this.isAlive() = false
run---end

### 1.4 sleep()方法

在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）。这个正在执行的线程是值`this.currentThread()`返回的线程。

```java
public class MyThread1 extends Thread {
    @Override
    public void run() {
        try {
            System.out.println("run threadName = " + this.currentThread().getName() + " begin");
            Thread.sleep(2000);
            System.out.println("run threadName = " + this.currentThread().getName() + " end");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class Run1 {
    public static void main(String[] args) {
        MyThread1 myThread = new MyThread1();
        System.out.println("begin = " + System.currentTimeMillis());
        myThread.run();
        System.out.println("end = " + System.currentTimeMillis());
    }
}
```

输出：

begin = 1537266574762
run threadName = main begin
run threadName = main end
end = 1537266576762

```java
public class MyThread2 extends Thread {
    @Override
    public void run() {
        try {
            System.out.println("run threadName = " + this.currentThread().getName() + " begin = " + System.currentTimeMillis());
            Thread.sleep(2000);
            System.out.println("run threadName = " + this.currentThread().getName() + " end = " + System.currentTimeMillis());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class Run2 {
    public static void main(String[] args) {
        MyThread2 myThread = new MyThread2();
        System.out.println("begin = " + System.currentTimeMillis());
        myThread.start();
        System.out.println("end = " + System.currentTimeMillis());
    }
}
```

begin = 1537266883296
end = 1537266883296
run threadName = Thread-0 begin = 1537266883297
run threadName = Thread-0 end = 1537266885298

### 1.6 getId()方法

是取得线程的唯一标识。

```java
public class Test {
    public static void main(String[] args) {
        Thread runThread = Thread.currentThread();
        System.out.println(runThread.getName() + " " + runThread.getId());
    }
}
```

输出：

main 1

### 1.7 停止线程

Thread.interrupt()方法，尽管方法的名称是停止，中止的意思，但这个方法不会终止一个正在运行的线程，还需要加入一个判断才可以完成线程的停止。

#### 1.7.1 停止不了的线程

调用interrupt来停止线程，但使用效果并不像for+break那样，马上就停止循环。此方法仅仅是在当前线程中打了一个停止的标记，并不是真的停止线程。

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        super.run();
        for (int i = 0; i < 100; i++) {
            System.out.println("i = " + (i + 1));
        }
    }
}
```

```java
public class Run {
    public static void main(String[] args) {
        try {
            MyThread thread = new MyThread();
            thread.start();
            Thread.sleep(2000);
            thread.interrupt();
        } catch (InterruptedException e) {
            System.out.println("main catch");
            e.printStackTrace();
        }
    }
}
```

调用interrupt()方法并没有停止线程。

#### 1.7.2 判断线程是否是停止状态

判断线程的状态是不是停止的。

1. this.interrupted()：测试当前线程都否已经中断。
2. this.isInterrupted()：测试线程都否已经中断。

















