# 6.类文件结构

代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，确实编程语言发展的一大步。

### 6.3 Class类文件的结构

任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。本章中，作者只是通俗地将任意一个有效的类或接口所应当满足的格式为Class文件格式，实际上它并不一定以磁盘文件的形式存在。

Class文件是一组以8位字节为基础单位的二进制流，各个数据项目按照严格顺序紧凑地排列在Class文件当中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有间隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前（Big-Endian是指最高位字节在地址最低位、最低位字节在地址最高位的顺序来存储数据）的方式分割成若干个8位字节存储。

根据Java虚拟机规范的规定，Class文件格式采用一种类似C语言结构体的微结构来存储数据，这种伪结构中只有两种数据类型，无符号数和表，后面的解析都要以这两种数据类型为基础，所以这里先介绍这两个概念。

无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节，4个字节，8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。

表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。

无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容器计数器加若干个连续的数据项的形式，这是称这一系列连续的某一类型的数据为某一类型的集合。

Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以数据项无论是顺序还是数量，甚至于数据存储的字节序这样的细节，都是被严格规定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。

#### 6.3.1 魔数与Class文件的版本

每个Class文件的头4个字节称为**魔数**（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如gif或者jpeg等在文件头中都存有魔数。使用魔数而不是拓展名来进行识别主要是基于安全方面的考虑，因为文件拓展名可以随意的改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。Class文件的魔数的确很有浪漫气息，值为：0xCAFEBABE（咖啡宝贝？），这个魔数值在Java还称作Oak语言的时候，就已经确定下来了，他还有一段很有趣的历史，据Java开发小组最关键成员Patrick Naughton所说：“我们一直在寻找一些好玩的，容易记忆的东西，选择0xCAFEBABE是因为它象征着著名咖啡品牌Peet's Coffee中深受欢迎的Baristas咖啡”吗，这个魔数似乎也预示着日后Java这个商标名称的出现。

紧接着魔数的四个字节存储的是Class文件的版本号，第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，JDK1.1之后的每个JDK大版本分布主版本号向上加1（JDK1.0~1.1使用了45.0~45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。

#### 6.3.2 常量池

紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。

由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的，常量池容量（偏移地址：0x00000008）为十六进制数0x0016，即十机制的22，这就代表常量池中有21项常量，索引值范围为1~21。在Class文件格式规定制定之时，设计者将第0项常量空出来是有特殊考虑的，这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为0来表示。**Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合，字段表集合，方法表集合等的容量计数都与一般习惯相同，是从0开始的。**

常量池中主要存放两个类常量：字面量（Literal）和符号引用（Symbolicc References）。字面量比较接近Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量：

- 类和接口的全限定名（Fully Qualified Name）
- 字段的名称和描述符（Descriptor）
- 方法的名称和描述符

#### 6.3.3 访问标志

在常量池结束之后，紧接着的两个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口，是否定义为public类型；是否定义为abstract类型，如果是类的话，是否被声明为final等。

#### 6.3.4 类索引、父类索引与接口索引集合

类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就是用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引结合中。

#### 6.3.5 字段表集合

字段表（field_info）用于描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。字段可以包括的信息有：字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符），字段数据类型（基本类型、对象、数组）、字段名称。上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能应用常量池汇总的常量来描述。

#### 6.3.6 方法表集合

Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的机构如同字段表一样，依次包括了访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性集合表（attributes）几项。

因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对的，synchronized、native、strictfp和abstract关键字可以修饰方法，所以方法表的访问标志中增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。

方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式汇总最具拓展性的一种数据项目。

#### 6.3.7 属性表集合

与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了些，不在要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不太认识的属性。