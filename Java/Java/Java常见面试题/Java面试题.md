### 1. 静态成员变量和静态方法可以被继承吗，为什么？

静态成员变量和静态方法可以被继承，但是不能被重写，它对子类隐藏，因此静态方法也不能实现多态。

### 2. 谈谈对多态的理解？

多态是指父类的某个方法被子类重写时，可以产生自己的功能行为，同一个操作用于不同对象，可以产生不同的执行结果。

多态的3个必要条件：

1. 继承父类
2. 复写父类方法
3. 父类引用指向子类对象

### 3. 为什么Java里的匿名内部类只能访问final修饰的外部变量？

内部类对象的生命周期会超过局部变量的生命周期。

- 局部变量的生命周期：当该方法被调用时，该方法中的局部变量在栈中被创建，当方法调用结束时，退栈，这些局部变量全部死亡。
- 匿名内部类对象的生命周期：创建一个匿名内部类对象，系统为该对象分配内存，直到没有引用变量指向分配给该对象的内存，它才会死亡(被JVM垃圾回收)。

所以，当成员方法已调用结束时，局部变量已死，但匿名内部类对象仍然存活着。

解决方法：匿名内部类对象可以访问同一个方法中被定义为final类型的局部变量。定义为final后，编译程序的实现方法：**对于匿名内部类对象要访问的所有final类型局部变量，都拷贝成为该对象中的一个数据成员。**这样，即使栈中局部变量已死亡，但被定义为final类型的局部变量的值永远不变，因而匿名内部类对象在局部变量死亡后，照样可以访问final类型的局部变量，因为它自己拷贝了一份，且与原局部变量的值始终一致。

### 4. 描述`Person person = new Person()`的过程

1. 查找Person.class，并加载到内存
2. 执行类中的静态代码块
3. 在堆内存中开辟内存空间，并分配内存地址
4. 在堆内存中建立对象的属性，并进行默认初始化
5. 对属性进行显示初始化
6. 对对象进行构造代码块初始化
7. 调用对象的构造函数进行初始化
8. 将对象的地址赋值给person变量

### 5. Java注解的原理，注解如何获取？

注解相当于一种标记，在程序中加了注解就等于为程序打上了某种标记，程序就可以利用Java的反射机制来了解类及各种元素有无何种标记，针对不同的标记，就去做相应的时间。标记可以加在包，类，字段，方法，方法的参数以及局部变量上。

### 6. String为什么要设计成不可变，StringBuffer与StringBuilder有什么区别？

- String：不可变，修改String时，不会在原有内存地址修改，而是重新指向一个对象，String用final修饰，不可以继承，String本质是final的char[]数组，所以char[]数组的内存地址不会被修改，而String也没有对外暴露修改char[]数组的方法。不可变性保证线程安全以及常量池的实现。
- StringBuffer：线程安全。
- StringBuilder：线程不安全。

### 7. JDK和JRE区别？

- JDK：是整个Java的核心，包括了Java运行环境JRE，一堆Java工具和Java基础类库。通过JDK将Java文件编译成字节码class文件。
- JRE：Java运行环境，不含开发环境，即没有编译器和调试器。将class文件加载到内存准备执行。

### 8. final关键字，抽象类可以使用final修饰吗？

- 修饰数据：包括成员变量和局部变量，该变量只能被赋值一次且不能被改变。对于成员变量来说，必须在声明时或者构造方法中对它赋值。
- 修饰方法：表示该方法无法被重写。
- 修饰类：表示该类无法被继承。

抽象类是被用于继承的，final修饰代表不可修改、不可继承的。所以不能用 final修饰抽象类。

### 9. 内部类和静态内部类的应用场景

- 静态内部类：降低包的深度，方便类的使用，静态内部类适用于包含类中，但又不依赖于外在的类，不使用外在类的非静态属性和方法，只是为了方便管理类结构而定义。在创建静态内部类的时候，不需要外部类的引用。
- 非静态内部类：持有外部类的引用，可以自由使用外部类的所有病例和方法。

### 10. 内部类为什么持有外部类的引用？

1. 编译器自动为内部类添加一个成员变量， 这个成员变量的类型和外部类的类型相同， 这个成员变量就是指向外部类对象的引用；
2. 编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型， 在构造方法内部使用这个参数为1中添加的成员变量赋值；
3. 在调用内部类的构造函数初始化内部类对象时， 会默认传入外部类的引用。

### 11. 接口和抽象类的区别

1. 抽象类要被子类继承，接口要被类实现。
2. 接口只能做方法声明，抽象类中可以作方法声明，也可以做方法实现。
3. 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
4. 接口是设计的结果，抽象类是重构的结果。
5. 抽象类和接口都是用来抽象具体对象的，但是接口的抽象级别最高。
6. 抽象类可以有具体的方法和属性，接口只能有抽象方法和不可变常量。
7. 抽象类主要用来抽象类别，接口主要用来抽象功能。

### 12. ==、equals、hashcode的区别和联系

1. ==是比较内存地址

```java
public class Test {
    public static void main(String[] args) {
        String s1 = "hello java";
        String s2 = "hello java";
        String s3 = new String("hello java");
        System.out.println(s1 == s2); //true
        System.out.println(s1 == s3); //false
        System.out.println(s1.equals(s3)); //true
    }
}
```

- s1== s2为true，对应常量池中同一个地址。
- s1== s2为false，new产生的对应在堆中，s3是堆中变量的引用，而s1是常量池中的引用。

2. equals是Object类中的方法

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

String源码中equals的实现：

```java
public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```

3. hashcode

```java
public native int hashCode();
```

**equals与hashcode的关系**：

1. 如果两个对象equals，hashcode一定相等。 
2. 如果两个对象不equals，他们的hashcode有可能相等。 
3. 如果两个对象hashcode相等，他们不一定equals。 
4. 如果两个对象hashcode不相等，他们一定不equals。 

### 13.sleep和wait的区别

- sleep()：Thread类的静态方法，导致程序暂停执行指定时间，让出CPU给其他线程，但是他的监控状态依然保持，当指定时间到达之后，又自动恢复运行状态，在调用sleep方法时，线程不会释放锁（只会让出CPU，不会释放锁）。
- wait()：Object的方法，在调用wait方法时，线程会放弃对象锁，进入等待此对象的等待池，只有针对此对象调用notify方法后此线程才离开等待池，并且再次获得CPU时间片才会继续执行（不仅让出CPU，还释放锁）。