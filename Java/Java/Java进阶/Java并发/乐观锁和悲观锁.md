# 乐观锁和悲观锁

独占锁是一种悲观锁，synchronized就是一种独占锁，它假设最坏的情况，认为一个线程修改共享数据的时候其他线程也会修改该数据，因此只能确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。

由于在进程挂起和恢复执行过程中存在着很大的开销。当一个线程正在等待锁时，它不能做任何事，所以悲观锁有很大的缺点。

所以有了乐观锁，核心思路是，每次不加锁而是假设修改数据之前其他线程一定不会修改，如果因为修改过产生冲突就失败而重试，知道成功为止。当数据争用不严重时，乐观锁效果更好。CAS就是乐观锁思想的应用。

### CAS

CAS包括三个操作数——内存位置V，预期原值A和新值B。

执行CAS操作的应用场景的一个例子，当一个线程需要修改共享变量的值，完成这个操作，先取出共享变量的值了，然后基于A的基础进行计算，得到新值B，更新共享变量的值，这个时候就可以调用CAS方法更新变量值了。

在Java中可以通过锁和循环CAS的方式来实现原子操作。Java中`java.util.concurrent.atomic`包相关类就是CAS的实现，

| 类名                        | 说明                                                         |
| --------------------------- | ------------------------------------------------------------ |
| AtomicBoolean               | 可以用原子方式更新的`boolean`值                              |
| AtomicInteger               | 可以用原子方式更新的`int`值                                  |
| AtomicIntegerArray          | 可以用原子方式更新其元素的`int`数组                          |
| AtomicIntegerFieldUpdater   | 基于反射的实用工具，可以对指定类的指定volatile`int`字段进行原子更新 |
| AtomicLong                  | 可以用原子方式更新的`long`值                                 |
| AtomicLongArray             | 可以用原子方式更新其元素的`long`数组                         |
| AtomicLongFieldUpdater      | 基于反射的实用工具，可以对指定类的指定volatile`long`字段进行原子更新 |
| AtomicMarkableReference     | 维护带有标记位的对象引用，可以用原子方式对其进行更新         |
| AtomicReference             | 可以用原子方式更新的对象引用                                 |
| AtomicReferenceArray        | 可以用原子方式更新其元素的对象引用数组                       |
| AtomicReferenceFieldUpdater | 基于反射的实用工具，可以对指定类的指定volatile字段进行原子更新 |
| AtomicStampedReference      | 维护带有整数“标志”的对象引用，可以用原子方式对其进行更新     |

