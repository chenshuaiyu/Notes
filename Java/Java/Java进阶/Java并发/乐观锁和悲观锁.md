# 乐观锁和悲观锁

独占锁是一种悲观锁，synchronized就是一种独占锁，它假设最坏的情况，认为一个线程修改共享数据的时候其他线程也会修改该数据，因此只能确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。

由于在进程挂起和恢复执行过程中存在着很大的开销。当一个线程正在等待锁时，它不能做任何事，所以悲观锁有很大的缺点。

所以有了乐观锁，核心思路是，每次不加锁而是假设修改数据之前其他线程一定不会修改，如果因为修改过产生冲突就失败而重试，知道成功为止。当数据争用不严重时，乐观锁效果更好。CAS就是乐观锁思想的应用。

### CAS

CAS包括三个操作数——内存位置V，预期原值A和新值B。

执行CAS操作的应用场景的一个例子，当一个线程需要修改共享变量的值，完成这个操作，先取出共享变量的值了，然后基于A的基础进行计算，得到新值B，更新共享变量的值，这个时候就可以调用CAS方法更新变量值了。

在Java中可以通过锁和循环CAS的方式来实现原子操作。Java中`java.util.concurrent.atomic`包相关类就是CAS的实现，

| 类名                        | 说明 |
| --------------------------- | ---- |
| AtomicBoolean               |      |
| AtomicInteger               |      |
| AtomicIntegerArray          |      |
| AtomicIntegerFieldUpdater   |      |
| AtomicLong                  |      |
| AtomicLongArray             |      |
| AtomicLongFieldUpdater      |      |
| AtomicMarkableReference     |      |
| AtomicReference             |      |
| AtomicReferenceArray        |      |
| AtomicReferenceFieldUpdater |      |
| AtomicStampedReference      |      |

