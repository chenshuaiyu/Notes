# volatile关键字

### 一、Java内存模型

Java内存模型规定了所有的变量都存储在主内存中。每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量（这些变量是从主内存中拷贝而来的）。线程对变量的所有操作（读取、赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成。

### 二、原子性

#### 1.定义

原子性：即一个操作或者多个操作，要么全部执行，并且执行的过程中不会被任何因素打断，要么就都不执行。

#### 2.实例

银行账户转账问题：从账户A减去1000元，网账户B中加上1000元，必须具备原子性。

#### 3.Java中的原子性

在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。

```java
x = 10; //直接将数值10赋值给x，也就是说线程执行这个语句时直接将10写入工作内存中

y = x; //2个操作，先去读取x的值，再将x的值写入工作内存

x++; //3个操作，读取x的值，加1操作，写入新的值

x = x + 1; //3个操作，读取x的值，加1操作，写入新的值
```

只有1具备原子性。

Java内存模式只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和lock操作。

### 三、可见性

#### 1.定义

可见性：指多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

#### 2.实例

```java
//线程1执行的代码
int i = 0;
i = 10;

//线程2执行的代码
j = i;
```

线程1执行`i = 10`时，会先把i的初始值加载到工作内存中，然后赋值为10，那么在线程1的工作内幕才能中i=10，却没有立即写入到主存当中。此时线程2执行`j = i`，会去主存读取i的值并加载到线程2的工作内存中，这是主存中i=0，那么j=0。

线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。

#### 3.Java中的可见性

- volatile关键字来保证可见性：当一个变量被volatile修饰时，会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它回去主存中读取新值。
- synchronized和Lock也能保证可见性：能保证在同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将变量的修改刷新到主存当中。

### 四、有序性

#### 1.定义

有序性：即程序执行的顺序按照代码的先后顺序执行。

#### 2.实例

```java
int i = 0;

boolean flag = false;

i = 1;			//语句1
flag = true;	//语句2
```

先定义int，再定义boolean，分别赋值。JVM真正执行的时候会发生指令重排序。

**指令重排序**：处理器为了提高程序运行效率，可能对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。

```java
int a = 10;	//语句1
int r = 2;	//语句2
a = a + 3;	//语句3
r = a * a;	//语句4
```

可能的一个执行顺序是2134，但是不可能为2143，因为处理器在进行重排序之前会考虑指令之间的数据依赖性，如果一个指令2必须用到指令1的结果，那么处理器会保证1会在2之前执行。

**指令重排序会影响线程并发执行的正确性。**

#### 3.Java中的有序性

- 可以通过volatile关键字来保证一定的有序性
- 可以通过Synchronized和Lock保证有序性

### 五、深入理解volatile关键字

#### 1.volatile保证可见性

一旦一个共享变量被volatile修饰，

- 保证了不同线程对这个变量进行操作时的可见性。
- 禁止进行指令重排序。

```java
//线程1
boolean stop = false;
while(!stop) {
    doSomething();
}

//线程2
stop = true;
```

stop被volatile修饰后，线程2修改工作内存中的值，将修改后的值写入主存，并是线程1工作内存中的stop缓存无效，当线程1读取时，发现自己的缓存无效，会从主存更新。

#### 2.volatile不能保证原子性

#### 3.volatile保证有序性

### 六、volatile的应用场景

synchronized关键字防止多个线程同时执行一段代码，那么会影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是注意volatile无法替代synchronized，因为volatile无法保证原子性。

使用volatile必须具备以下条件：

1. 对变量的写操作不依赖于当前值。
2. 该变量没有包含在具有其他变量的不变式中。

使用场景：

1. 状态标记量

```java
volatile boolean flag = false;

//线程1
while(!flag) {
    doSomething();
}

//线程2
public void setFlag() {
    flag = true;
}
```

2. 单例模式中的double check

```java
class LazySingleton{
    private volatile static LazySingleton instance = null;
    
    private LazySingleton(){}
    
    public static LazySingleton getInstance(){
        if(instance == null){
            synchronized(LazySingleton.class){
                if(instance == null){
                    instance = new LazySingleton();
                }
            }
        }
        return instance;
    }  
}
```

`instance = new LazySingleton();`不是一个原子操作，事实上在JVM中做了3件事：

1. 给instance分配内存。
2. 调用LazySingleton的构造函数来初始化成员变量。
3. 将instance对象指向分配的内存空间。

但在JVM的即时编译器中存在指令重排序的优化，也就说2，3步的顺序是不能保证的。