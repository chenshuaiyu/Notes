# 1.并发编程的挑战

### 1.1 上下文切换

即使单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。

CPU通过时间片分配算法来循环执行任务，当前任务一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便在下次切换回这个任务时，可以加载这个任务的状态。**所以任务从保存到再加载的过程就是一次上下文切换。**

#### 1.1.1 多线程一定快吗

Q：并发执行一定比串行执行快吗？

A：不一定，当并发执行累加操作不超过百万次时，速度会比串行执行累加操作要慢。**因为线程有创建和上下文切换的开销。**

#### 1.1.2 测试上下文切换次数和时长

使用Lmbench3可以测量上下文切换的时长，使用vmstat测量上下文切换次数的示例。

CS（Content Switch）表示上下文切换的次数，从测试结果可以看到，上下文每1秒切换1000多次。

#### 1.1.3 如何减少上下文切换

- 无锁并发编程：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。
- CAS算法：Java的Atomic包使用CAS算法来更新数据，而不需要加锁。
- 使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程多处于等待状态。
- 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

### 1.2 死锁

避免死锁的几个常见方法：

- 避免一个线程同时获取多个锁。
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
- 尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制。
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。